<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LTSD - LT Studio Design</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        @font-face {
            font-family: 'butler_medium';
            src: url('assets/fonts/butler-medium.woff2') format('woff2'),
                 url('assets/fonts/butler-medium.woff') format('woff');
            font-weight: 500;
            font-style: normal;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'butler_medium', serif;
            background: #252525;
            color: white;
            overflow: hidden;
            cursor: none;
        }
        
        /* INTRO SCREEN */
        #intro-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #252525;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 1s ease, transform 1s ease;
        }
        
        #intro-screen.hidden {
            opacity: 0;
            transform: scale(0.8);
            pointer-events: none;
        }

        /* TRANSICI√ìN FRAGMENTADA SIMPLIFICADA */
        .fragment-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 2000;
            pointer-events: none;
            opacity: 0;
            background: #252525;
        }

        .fragment-overlay.active {
            opacity: 1;
        }

        .fragment {
            position: absolute;
            background: #252525;
            transition: all 1s ease-out;
        }

        .fragment.animate-out {
            transform: translateX(var(--dx)) translateY(var(--dy)) rotate(var(--rotation)) scale(0);
            opacity: 0;
        }
        
        .intro-text {
            font-size: 48px;
            font-weight: 300;
            letter-spacing: 8px;
            text-align: center;
            font-family: 'butler_medium', serif;
        }

        .intro-text .letter {
            display: inline-block;
            color: #444;
            transition: color 0.8s ease;
        }

        .intro-text .letter.filled {
            color: white;
        }

        .intro-text-container {
            position: relative;
            text-align: center;
        }

        .intro-loader {
            width: 100%;
            height: 2px;
            background-color: #444;
            margin-top: 20px;
            position: relative;
            overflow: hidden;
        }

        .loader-bar {
            width: 0%;
            height: 100%;
            background-color: white;
            transition: width 2.5s ease-in-out;
        }
        
        /* PARTICLES */
        #particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .particle {
            position: absolute;
            background: white;
            border-radius: 50%;
            opacity: 0.3;
            animation: float 6s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            33% { transform: translateY(-30px) rotate(120deg); }
            66% { transform: translateY(30px) rotate(240deg); }
        }
        
        /* MAIN SCREEN */
        #main-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            opacity: 0;
            transform: scale(1.2);
            transition: opacity 1s ease, transform 1s ease;
            z-index: 100;
        }

        /* FONDO COMPLETO DE IMAGEN √öNICA */
        .full-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-color: #252525;
            opacity: 0.6;
            z-index: 0;
            transition: all 1s ease;
        }

        .full-background.active {
            opacity: 0.8;
        }
        
        #main-screen.visible {
            opacity: 1;
            transform: scale(1);
        }


        
        /* LOGO */
        .logo {
            position: fixed;
            top: 30px;
            left: 30px;
            font-size: 24px;
            font-weight: 500;
            letter-spacing: 4px;
            z-index: 200;
            mix-blend-mode: exclusion;
            font-family: 'butler_medium', serif;
        }

        /* NAVEGACI√ìN SUPERIOR */
        .top-nav {
            position: fixed;
            top: 30px;
            right: 30px;
            display: flex;
            gap: 30px;
            z-index: 200;
            font-family: 'butler_medium', serif;
        }

        .top-nav-item {
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            font-weight: 300;
            letter-spacing: 1px;
            text-transform: uppercase;
            cursor: pointer;
            transition: color 0.3s ease;
            text-decoration: none;
        }

        .top-nav-item:hover,
        .top-nav-item.active {
            color: white;
        }

        /* MODAL ALL PROJECTS */
        .all-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(37, 37, 37, 0.95);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .all-modal.visible {
            display: flex;
        }

        .modal-content {
            max-width: 1200px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            padding: 40px;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 40px;
        }

        .modal-title {
            font-size: 32px;
            font-weight: 300;
            letter-spacing: 2px;
            font-family: 'butler_medium', serif;
        }

        .close-modal {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 10px;
        }

        .projects-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
        }

        .project-card {
            aspect-ratio: 4/3;
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            position: relative;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .project-card:hover {
            transform: scale(1.05);
        }

        .project-card-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            padding: 20px;
            border-radius: 0 0 8px 8px;
        }

        .project-card-title {
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 5px;
        }

        .project-card-location {
            font-size: 14px;
            opacity: 0.7;
        }
        
        /* CIRCLE CONTAINER */
        .circle-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            height: 600px;
            z-index: 150;
            border-radius: 50%;
            overflow: hidden;
            background: inherit; /* Hereda el fondo de la p√°gina */
        }
        
        /* BACKGROUND IMAGES */

        
        /* CIRCLE BORDER */
        .circle-border {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            z-index: 3;
            mix-blend-mode: exclusion;
            transition: border-color 0.3s ease;
        }

        .circle-inner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            height: 90%;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            mix-blend-mode: overlay;
        }

        /* BARRA CIRCULAR DE PROGRESO */
        .circular-progress-bar {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 115%;
            height: 115%;
            z-index: 4;
        }

        .progress-circle-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .progress-circle-bg {
            stroke: rgba(255, 255, 255, 0.1);
            stroke-width: 2;
            fill: transparent;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
        }

        .progress-circle-fill {
            stroke: rgba(255, 255, 255, 0.4);
            stroke-width: 2;
            fill: transparent;
            stroke-linecap: round;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
            transition: stroke-dasharray 0.3s ease;
        }

        /* PUNTOS DE PROYECTOS DENTRO DE LA BARRA */
        .project-dots {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        .project-dot {
            position: absolute;
            width: 3px;
            height: 3px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .project-dot.active {
            background: white;
            transform: scale(1.8);
        }
        
        /* PROJECT TEXT */
        .project-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 4;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        .project-text.active {
            opacity: 1;
        }
        
        .project-name {
            font-size: 32px;
            font-weight: 600;
            margin-bottom: 8px;
            text-shadow: 2px 2px 10px rgba(0,0,0,0.8);
        }
        
        .project-location {
            font-size: 16px;
            font-weight: 300;
            opacity: 0.8;
            text-shadow: 1px 1px 5px rgba(0,0,0,0.8);
        }
        
        /* NAVIGATION LATERAL */
        .nav-prev {
            position: fixed;
            left: calc(50% - 500px);
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            z-index: 200;
        }

        .nav-next {
            position: fixed;
            right: calc(50% - 500px);
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            z-index: 200;
        }

        .nav-line {
            width: 100px;
            height: 1px;
            background: rgba(255, 255, 255, 0.3);
            margin: 0 20px;
        }

        .nav-button {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            font-weight: 300;
            letter-spacing: 1px;
            cursor: pointer;
            transition: color 0.3s ease;
            font-family: 'butler_medium', serif;
            text-transform: uppercase;
        }

        .nav-button:hover {
            color: white;
        }

        .nav-button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* PROGRESS BAR ABAJO DERECHA */
        .progress-info {
            position: fixed;
            bottom: 50px;
            right: 50px;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 200;
            font-family: 'butler_medium', serif;
        }

        .project-number {
            color: white;
            font-size: 16px;
            font-weight: 300;
            min-width: 20px;
        }

        .progress-container {
            width: 80px;
            height: 2px;
            background: rgba(255, 255, 255, 0.2);
        }

        .progress-bar {
            height: 100%;
            background: white;
            width: 0%;
            transition: width 0.1s linear;
        }

        .project-total {
            color: rgba(255, 255, 255, 0.6);
            font-size: 16px;
            font-weight: 300;
        }


        
        /* CURSOR CUSTOM */
        .custom-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            mix-blend-mode: exclusion;
            transition: transform 0.1s ease;
        }
        
        /* RESPONSIVE */
        @media (max-width: 768px) {
            .intro-text {
                font-size: 2.5rem;
            }
            
            .circle-container {
                width: 400px;
                height: 400px;
            }
            
            .project-name {
                font-size: 24px;
            }
        }

        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1001;
            pointer-events: none;
            opacity: 0;
            transition: opacity 1s ease;
        }

        #three-container.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="three-container"></div>
    <!-- CURSOR PERSONALIZADO -->
    <div class="custom-cursor" id="cursor"></div>
    
    <!-- INTRO SCREEN -->
    <div id="intro-screen">
        <div id="particles"></div>
        <div class="intro-text-container">
            <div class="intro-text"></div>
            <div class="intro-loader">
                <div class="loader-bar"></div>
            </div>
        </div>
    </div>

    <!-- TRANSICI√ìN FRAGMENTADA -->
    <div class="fragment-overlay" id="fragment-overlay"></div>
    
    <!-- FONDO COMPLETO -->
    <div class="full-background" id="full-bg"></div>

    <!-- MAIN SCREEN -->
    <div id="main-screen">
        <!-- LOGO -->
        <div class="logo">LTSD</div>

        <!-- NAVEGACI√ìN SUPERIOR -->
        <div class="top-nav">
            <div class="top-nav-item" onclick="showAllProjects()">all</div>
            <div class="top-nav-item" onclick="showAbout()">about</div>
        </div>
        
        <!-- C√çRCULO INTERACTIVO -->
        <div class="circle-container">
            
            <!-- BORDE DEL C√çRCULO -->
            <div class="circle-border"></div>
            <div class="circle-inner"></div>

            <!-- BARRA CIRCULAR DE PROGRESO -->
            <div class="circular-progress-bar">
                <svg class="progress-circle-container" width="100%" height="100%">
                    <circle class="progress-circle-bg" cx="50%" cy="50%" r="48%"></circle>
                    <circle class="progress-circle-fill" cx="50%" cy="50%" r="48%" id="progress-circle"></circle>
                </svg>
                <div class="project-dots" id="project-dots">
                    <!-- Se generan din√°micamente -->
                </div>
            </div>
            
            <!-- TEXTO DEL PROYECTO -->
            <div class="project-text" data-project="0">
                <div class="project-name">PARK MANSION</div>
                <div class="project-location">Minami Azabu</div>
            </div>
            <div class="project-text" data-project="1">
                <div class="project-name">KAWANA</div>
                <div class="project-location">Silence Kawana</div>
            </div>
            <div class="project-text" data-project="2">
                <div class="project-name">PARK LE JADE</div>
                <div class="project-location">Shirokane Residence</div>
            </div>
            <div class="project-text" data-project="3">
                <div class="project-name">SEVENS VILLA</div>
                <div class="project-location">Karuizawa</div>
            </div>
            <div class="project-text" data-project="4">
                <div class="project-name">HIKAWA GARDENS</div>
                <div class="project-location">Tokyo</div>
            </div>
            <div class="project-text" data-project="5">
                <div class="project-name">ONE AVENUE</div>
                <div class="project-location">Central District</div>
            </div>
            <div class="project-text" data-project="6">
                <div class="project-name">CENTURY FOREST</div>
                <div class="project-location">Urban Integration</div>
            </div>
            <div class="project-text" data-project="7">
                <div class="project-name">PROUD</div>
                <div class="project-location">Rokakoen</div>
            </div>
            <div class="project-text" data-project="8">
                <div class="project-name">NISHIAZABU RESIDENCE</div>
                <div class="project-location">Nishiazabu</div>
            </div>
            <div class="project-text" data-project="9">
                <div class="project-name">ITOHPIA JIYUGAOKA</div>
                <div class="project-location">Jiyugaoka</div>
            </div>
            <div class="project-text" data-project="10">
                <div class="project-name">URBAN VILLA</div>
                <div class="project-location">Central Tokyo</div>
            </div>
            <div class="project-text" data-project="11">
                <div class="project-name">MODERN HOUSE</div>
                <div class="project-location">Shibuya</div>
            </div>
        </div>
        
        <!-- NAVEGACI√ìN LATERAL -->
        <div class="nav-prev">
            <button class="nav-button" id="prev-btn" onclick="previousProject()">prev</button>
            <div class="nav-line"></div>
        </div>

        <div class="nav-next">
            <div class="nav-line"></div>
            <button class="nav-button" id="next-btn" onclick="nextProject()">next</button>
        </div>

        <!-- PROGRESO ABAJO DERECHA -->
        <div class="progress-info">
            <div class="project-number" id="current-num">1</div>
            <div class="progress-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            <div class="project-total">12</div>
        </div>


    </div>

    <!-- MODAL ALL PROJECTS -->
    <div class="all-modal" id="all-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">All Projects</div>
                <button class="close-modal" onclick="closeAllProjects()">√ó</button>
            </div>
            <div class="projects-grid" id="projects-grid">
                <!-- Se llena din√°micamente -->
            </div>
        </div>
    </div>

    <!-- MODAL ABOUT -->
    <div class="all-modal" id="about-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">About LT Studio Design</div>
                <button class="close-modal" onclick="closeAbout()">√ó</button>
            </div>
            <div style="line-height: 1.6; opacity: 0.9;">
                <p style="margin-bottom: 20px;">
                    LT Studio Design es un estudio de arquitectura contempor√°nea que se especializa en crear
                    espacios √∫nicos que combinan funcionalidad, est√©tica y sostenibilidad.
                </p>
                <p style="margin-bottom: 20px;">
                    Nuestro enfoque se centra en entender las necesidades espec√≠ficas de cada cliente y
                    traducirlas en dise√±os arquitect√≥nicos innovadores que respetan el entorno y maximizan
                    la experiencia del usuario.
                </p>
                <p style="margin-bottom: 20px;">
                    Cada proyecto es una oportunidad para explorar nuevas formas de habitar el espacio,
                    integrando tecnolog√≠a avanzada con materiales nobles y t√©cnicas constructivas sostenibles.
                </p>
                <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.2);">
                    <strong>Servicios:</strong><br>
                    ‚Ä¢ Dise√±o Arquitect√≥nico<br>
                    ‚Ä¢ Planificaci√≥n Urbana<br>
                    ‚Ä¢ Dise√±o de Interiores<br>
                    ‚Ä¢ Consultor√≠a en Sostenibilidad<br>
                    ‚Ä¢ Gesti√≥n de Proyectos
                </div>
            </div>
        </div>
    </div>

    <script>
        // CONFIGURACI√ìN
        const PROJECTS = [
            {
                name: 'PARK MANSION',
                location: 'Minami Azabu',
                image: 'https://picsum.photos/seed/park-mansion/600/600',
                duration: 4000
            },
            {
                name: 'KAWANA',
                location: 'Silence Kawana',
                image: 'https://picsum.photos/seed/kawana/600/600',
                duration: 4000
            },
            {
                name: 'PARK LE JADE',
                location: 'Shirokane Residence',
                image: 'https://picsum.photos/seed/park-le-jade/600/600',
                duration: 4000
            },
            {
                name: 'SEVENS VILLA',
                location: 'Karuizawa',
                image: 'https://picsum.photos/seed/sevens-villa/600/600',
                duration: 4000
            },
            {
                name: 'HIKAWA GARDENS',
                location: 'Tokyo',
                image: 'https://picsum.photos/seed/hikawa-gardens/600/600',
                duration: 4000
            },
            {
                name: 'ONE AVENUE',
                location: 'Central District',
                image: 'https://picsum.photos/seed/one-avenue/600/600',
                duration: 4000
            },
            {
                name: 'CENTURY FOREST',
                location: 'Urban Integration',
                image: 'https://picsum.photos/seed/century-forest/600/600',
                duration: 4000
            },
            {
                name: 'PROUD',
                location: 'Rokakoen',
                image: 'https://picsum.photos/seed/proud/600/600',
                duration: 4000
            },
            {
                name: 'NISHIAZABU RESIDENCE',
                location: 'Nishiazabu',
                image: 'https://picsum.photos/seed/nishiazabu/600/600',
                duration: 4000
            },
            {
                name: 'ITOHPIA JIYUGAOKA',
                location: 'Jiyugaoka',
                image: 'https://picsum.photos/seed/itohpia/600/600',
                duration: 4000
            },
            {
                name: 'URBAN VILLA',
                location: 'Central Tokyo',
                image: 'https://picsum.photos/seed/urban-villa/600/600',
                duration: 4000
            },
            {
                name: 'MODERN HOUSE',
                location: 'Shibuya',
                image: 'https://picsum.photos/seed/modern-house/600/600',
                duration: 4000
            }
        ];
        
        let currentProject = 0;
        let projectTimer = null;
        let progressTimer = null;
        
        // CURSOR PERSONALIZADO
        const cursor = document.getElementById('cursor');
        let isOverCircle = false;

        document.addEventListener('mousemove', (e) => {
            cursor.style.left = e.clientX - 10 + 'px';
            cursor.style.top = e.clientY - 10 + 'px';
        });

        // INTERACCI√ìN CON EL C√çRCULO
        let isDragging = false;
        let dragStartY = 0;
        let dragStartProject = 0;

        function setupCircleInteraction() {
            const circleContainer = document.querySelector('.circle-container');
            const circleBorder = document.querySelector('.circle-border');
            const circleInner = document.querySelector('.circle-inner');

            if (circleContainer) {
                // Hover effects
                circleContainer.addEventListener('mouseenter', () => {
                    isOverCircle = true;
                    cursor.style.transform = 'scale(2)';
                    cursor.style.mixBlendMode = 'exclusion';
                    circleBorder.style.borderColor = 'rgba(255, 255, 255, 0.8)';
                    if (circleInner) {
                        circleInner.style.borderColor = 'rgba(255, 255, 255, 0.2)';
                    }
                });

                circleContainer.addEventListener('mouseleave', () => {
                    isOverCircle = false;
                    cursor.style.transform = 'scale(1)';
                    cursor.style.mixBlendMode = 'difference';
                    circleBorder.style.borderColor = 'rgba(255, 255, 255, 0.4)';
                    if (circleInner) {
                        circleInner.style.borderColor = 'rgba(255, 255, 255, 0.1)';
                    }
                });

                // Drag functionality
                circleContainer.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    dragStartY = e.clientY;
                    dragStartProject = currentProject;
                    circleContainer.style.cursor = 'grabbing';
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (isDragging && isOverCircle) {
                        const deltaY = e.clientY - dragStartY;
                        const sensitivity = 50; // px needed to change project
                        const projectChange = Math.floor(deltaY / sensitivity);

                        let newProject = dragStartProject + projectChange;
                        newProject = Math.max(0, Math.min(PROJECTS.length - 1, newProject));

                        if (newProject !== currentProject) {
                            changeProject(newProject);
                        }
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        circleContainer.style.cursor = '';
                        // Restart progress after drag
                        setTimeout(() => {
                            startProgress();
                        }, 500);
                    }
                });
            }
        }
        
        // TRANSICI√ìN FRAGMENTADA SIMPLIFICADA
        function startFragmentTransition() {
            console.log('üåü Iniciando transici√≥n fragmentada');

            const introScreen = document.getElementById('intro-screen');
            const mainScreen = document.getElementById('main-screen');

            // Transici√≥n suave sin fragmentos complejos
            introScreen.style.transition = 'opacity 1s ease-out, transform 1s ease-out';
            introScreen.style.opacity = '0';
            // ¬°NO M√ÅS SCALE! Solo opacity

            setTimeout(() => {
                // Ocultar intro completamente
                introScreen.classList.add('hidden');
                introScreen.style.display = 'none';

                // Mostrar main screen
                mainScreen.classList.add('visible');
                mainScreen.style.opacity = '1';
                mainScreen.style.transform = 'scale(1)';

                console.log('‚úÖ Transici√≥n completada - Main screen visible');

                // Inicializar main screen despu√©s de la transici√≥n
                setTimeout(() => {
                    changeProject(0);
                    startProgress();
                    console.log('‚úÖ Main screen inicializado con proyecto 0');
                }, 300);
            }, 1000);
        }

        // CREAR PART√çCULAS
        function createParticles() {
            const particlesContainer = document.getElementById('particles');

            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.width = (Math.random() * 4 + 1) + 'px';
                particle.style.height = particle.style.width;
                particle.style.animationDelay = Math.random() * 6 + 's';
                particle.style.animationDuration = (Math.random() * 4 + 4) + 's';

                particlesContainer.appendChild(particle);
            }
        }

        function createTextTexture(text, style) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const canvasWidth = 1024;
            const canvasHeight = 512;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            ctx.fillStyle = style.backgroundColor;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            ctx.font = style.font;
            ctx.fillStyle = style.color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvasWidth / 2, canvasHeight / 2);

            return new THREE.CanvasTexture(canvas);
        }

        // ANIMAR TEXTO LETRA POR LETRA
        function animateIntroText() {
            console.log('üìù Iniciando animaci√≥n de texto intro');
            const introText = document.querySelector('.intro-text');
            const loaderBar = document.querySelector('.loader-bar');
            const text = 'LT STUDIO DESIGN';

            if (!introText || !loaderBar) {
                console.error('‚ùå No se encontr√≥ .intro-text o .loader-bar');
                return;
            }

            introText.innerHTML = '';

            // Crear spans para cada letra
            const letters = [];
            text.split('').forEach((letter, index) => {
                const span = document.createElement('span');
                span.className = 'letter';
                span.textContent = letter === ' ' ? '\u00A0' : letter;
                introText.appendChild(span);
                letters.push(span);
            });

            console.log(`üìù Creadas ${letters.length} letras`);

            // Animar letra por letra de gris a blanco
            letters.forEach((letter, index) => {
                setTimeout(() => {
                    letter.classList.add('filled');
                    console.log(`ÔøΩÔøΩ Letra ${index + 1} animada`);

                    // Si es la primera letra, iniciar la barra de carga
                    if (index === 0) {
                        loaderBar.style.width = '100%';
                    }

                    // Si es la √∫ltima letra, iniciar la animaci√≥n de fragmentos
                    if (index === letters.length - 1) {
                        console.log('üéØ √öltima letra completada, iniciando animaci√≥n de fragmentos');
                        setTimeout(() => {
                            // Ocultar texto y barra de carga
                            introText.style.transition = 'opacity 0.5s';
                            introText.style.opacity = '0';
                            document.querySelector('.intro-loader').style.transition = 'opacity 0.5s';
                            document.querySelector('.intro-loader').style.opacity = '0';

                            setTimeout(() => {
                                if (window.startFragmentAnimation) {
                                    window.startFragmentAnimation();
                                }
                            }, 500);

                        }, 1000);
                    }
                }, index * 150); // 150ms entre letras para mejor visualizaci√≥n
            });
        }
        
        // INICIALIZAR PRIMERA IMAGEN DE FONDO
        function initProjectImages() {
            console.log(`üñºÔ∏è Inicializando imagen de fondo √∫nica`);

            // Configurar primera imagen
            if (PROJECTS[0]) {
                updateBackgroundImage(0);
            }
        }

        // ACTUALIZAR IMAGEN DE FONDO
        function updateBackgroundImage(index) {
            const fullBg = document.getElementById('full-bg');
            if (fullBg && PROJECTS[index]) {
                const imageUrl = PROJECTS[index].image;
                const timestamp = Date.now();
                const finalUrl = `${imageUrl}?cache=${timestamp}&id=${index}`;

                const img = new Image();
                img.onload = () => {
                    console.log(`üì• Imagen de fondo cargada: ${PROJECTS[index].name}`);
                    fullBg.style.backgroundImage = `url("${finalUrl}")`;
                    fullBg.classList.remove('active');
                    setTimeout(() => {
                        fullBg.classList.add('active');
                    }, 100);
                };
                img.onerror = () => {
                    console.log(`‚ùå Error cargando imagen, usando fallback`);
                    const fallbackUrl = `https://picsum.photos/seed/backup-${index}-${timestamp}/600/600`;
                    fullBg.style.backgroundImage = `url("${fallbackUrl}")`;
                };
                img.src = finalUrl;
            }
        }
        
        // CAMBIAR PROYECTO
        function changeProject(index) {
            // Limpiar intervalos
            if (progressTimer) clearInterval(progressTimer);

            // Ocultar proyecto actual
            document.querySelectorAll('.project-text').forEach(text => {
                text.classList.remove('active');
            });

            // Mostrar nuevo proyecto
            const newText = document.querySelector(`.project-text[data-project="${index}"]`);

            if (newText) newText.classList.add('active');

            // Actualizar imagen de fondo √∫nica
            updateBackgroundImage(index);

            currentProject = index;

            // Actualizar contador
            document.getElementById('current-num').textContent = (index + 1).toString();

            // Actualizar indicador de proyectos
            updateProjectIndicator(index);

            // Actualizar botones de navegaci√≥n
            document.getElementById('prev-btn').disabled = (index === 0);
            document.getElementById('next-btn').disabled = (index === PROJECTS.length - 1);

            console.log(`‚úÖ Proyecto cambiado a: ${PROJECTS[index].name}`);
        }
        
        // INICIAR BARRA DE PROGRESO
        // CONFIGURACI√ìN DE INDICADOR DE PROYECTOS
        function setupProjectIndicator() {
            const progressCircle = document.getElementById('progress-circle');
            const dotsContainer = document.getElementById('project-dots');

            // Configurar c√≠rculo de progreso
            if (progressCircle) {
                const radius = progressCircle.r.baseVal.value;
                const circumference = 2 * Math.PI * radius;
                progressCircle.style.strokeDasharray = circumference;
                progressCircle.style.strokeDashoffset = circumference;
            }

            // Configurar puntos de proyectos
            if (dotsContainer) {
                dotsContainer.innerHTML = '';

                // Crear puntos para cada proyecto alrededor del c√≠rculo
                PROJECTS.forEach((project, index) => {
                    const dot = document.createElement('div');
                    dot.className = 'project-dot';
                    dot.dataset.project = index;

                    // Calcular posici√≥n alrededor del c√≠rculo
                    const angle = (index / PROJECTS.length) * 360 - 90; // -90 para empezar arriba
                    const radian = (angle * Math.PI) / 180;
                    const radius = 50; // porcentaje del contenedor

                    const x = 50 + radius * Math.cos(radian);
                    const y = 50 + radius * Math.sin(radian);

                    dot.style.left = x + '%';
                    dot.style.top = y + '%';
                    dot.style.transform = 'translate(-50%, -50%)';

                    dotsContainer.appendChild(dot);
                });

                // Activar el primer punto
                updateProjectIndicator(0);
            }
        }

        // ACTUALIZAR INDICADOR DE PROYECTOS
        function updateProjectIndicator(activeIndex) {
            const dots = document.querySelectorAll('.project-dot');
            dots.forEach((dot, index) => {
                dot.classList.toggle('active', index === activeIndex);
            });

            // Actualizar barra circular de progreso
            const progressCircle = document.getElementById('progress-circle');
            if (progressCircle) {
                const progress = (activeIndex + 1) / PROJECTS.length;
                const radius = progressCircle.r.baseVal.value;
                const circumference = 2 * Math.PI * radius;
                const offset = circumference - (progress * circumference);
                progressCircle.style.strokeDashoffset = offset;
            }
        }

        function startProgress() {
            const progressBar = document.getElementById('progress-bar');
            const duration = PROJECTS[currentProject].duration;
            let progress = 0;

            progressBar.style.width = '0%';

            const increment = 100 / (duration / 50); // 50ms intervals

            progressTimer = setInterval(() => {
                progress += increment;
                progressBar.style.width = progress + '%';

                if (progress >= 100) {
                    clearInterval(progressTimer);
                    autoNextProject();
                }
            }, 50);
        }
        
        // SIGUIENTE PROYECTO
        function nextProject() {
            if (currentProject < PROJECTS.length - 1) {
                changeProject(currentProject + 1);
                startProgress();
            }
        }

        // PROYECTO ANTERIOR
        function previousProject() {
            if (currentProject > 0) {
                changeProject(currentProject - 1);
                startProgress();
            }
        }

        // AUTO NEXT (para progreso autom√°tico)
        function autoNextProject() {
            const nextIndex = (currentProject + 1) % PROJECTS.length;
            changeProject(nextIndex);
            startProgress();
        }
        
        // INICIALIZAR APLICACI√ìN
        function initApp() {
            console.log('üöÄ Inicializando aplicaci√≥n LTSD');

            // Asegurar que intro est√© visible y main oculto
            const introScreen = document.getElementById('intro-screen');
            const mainScreen = document.getElementById('main-screen');

            if (introScreen) {
                introScreen.classList.remove('hidden');
                introScreen.style.opacity = '1';
                introScreen.style.transform = 'scale(1)';
                console.log('‚úÖ Intro screen visible');
            }

            if (mainScreen) {
                mainScreen.classList.remove('visible');
                mainScreen.style.opacity = '0';
                console.log('‚úÖ Main screen oculto');
            }

            // Crear part√≠culas
            createParticles();

            // Animar texto intro (incluye transici√≥n autom√°tica)
            setTimeout(() => {
                animateIntroText();
            }, 500); // Peque√±o delay para asegurar que todo est√© listo

            // Inicializar im√°genes
            initProjectImages();

            // Configurar interacci√≥n del c√≠rculo
            setupCircleInteraction();

            // Configurar indicador de proyectos
            setupProjectIndicator();
        }
        
        // FUNCIONES DE MODAL
        function showAllProjects() {
            const modal = document.getElementById('all-modal');
            const grid = document.getElementById('projects-grid');

            // Limpiar grid
            grid.innerHTML = '';

            // Crear cards para cada proyecto
            PROJECTS.forEach((project, index) => {
                const card = document.createElement('div');
                card.className = 'project-card';
                card.style.backgroundImage = `url("${project.image}")`;
                card.onclick = () => goToProject(index);

                card.innerHTML = `
                    <div class="project-card-overlay">
                        <div class="project-card-title">${project.name}</div>
                        <div class="project-card-location">${project.location}</div>
                    </div>
                `;

                grid.appendChild(card);
            });

            modal.classList.add('visible');
        }

        function closeAllProjects() {
            document.getElementById('all-modal').classList.remove('visible');
        }

        function showAbout() {
            document.getElementById('about-modal').classList.add('visible');
        }

        function closeAbout() {
            document.getElementById('about-modal').classList.remove('visible');
        }

        function goToProject(index) {
            // Usar √≠ndice para crear URLs consistentes
            const projectUrls = [
                'projects/park-mansion-nuevo.html',
                'projects/kawana-nuevo.html',
                'projects/park-mansion-nuevo.html', // placeholder
                'projects/kawana-nuevo.html', // placeholder
                'projects/park-mansion-nuevo.html', // placeholder
                'projects/kawana-nuevo.html', // placeholder
                'projects/park-mansion-nuevo.html', // placeholder
                'projects/kawana-nuevo.html', // placeholder
                'projects/park-mansion-nuevo.html', // placeholder
                'projects/kawana-nuevo.html', // placeholder
                'projects/park-mansion-nuevo.html', // placeholder
                'projects/kawana-nuevo.html' // placeholder
            ];

            window.location.href = projectUrls[index] || 'projects/park-mansion-nuevo.html';
        }

        // CLICKS EN PROYECTOS (NAVEGACI√ìN A P√ÅGINAS INDIVIDUALES)
        document.addEventListener('click', (e) => {
            if (e.target.closest('.circle-container')) {
                goToProject(currentProject);
            }
        });
        
        // INICIAR CUANDO LA P√ÅGINA CARGUE
        console.log('üîÑ Registrando DOMContentLoaded listener');
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üì± DOM Content Loaded - iniciando app');
            initApp();
        });

        // Backup en caso de que DOMContentLoaded ya haya pasado
        if (document.readyState === 'loading') {
            console.log('‚è≥ DOM still loading, waiting for DOMContentLoaded');
        } else {
            console.log('‚ö° DOM already loaded, iniciando inmediatamente');
            setTimeout(initApp, 100);
        }

        console.log('üéâ LTSD App script cargado completamente');
    </script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.11.0/dist/gsap.min.js"></script>
    <script>
    !function(e,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],n):n(e.BAS={},e.THREE)}(this,function(e,n){"use strict";function t(e,t){n.ShaderMaterial.call(this);var i=e.uniformValues;if(delete e.uniformValues,this.setValues(e),this.uniforms=n.UniformsUtils.merge([t,this.uniforms]),this.setUniformValues(i),i&&(i.map&&(this.defines.USE_MAP=""),i.normalMap&&(this.defines.USE_NORMALMAP=""),i.envMap&&(this.defines.USE_ENVMAP=""),i.aoMap&&(this.defines.USE_AOMAP=""),i.specularMap&&(this.defines.USE_SPECULARMAP=""),i.alphaMap&&(this.defines.USE_ALPHAMAP=""),i.lightMap&&(this.defines.USE_LIGHTMAP=""),i.emissiveMap&&(this.defines.USE_EMISSIVEMAP=""),i.bumpMap&&(this.defines.USE_BUMPMAP=""),i.displacementMap&&(this.defines.USE_DISPLACEMENTMAP=""),i.roughnessMap&&(this.defines.USE_DISPLACEMENTMAP=""),i.roughnessMap&&(this.defines.USE_ROUGHNESSMAP=""),i.metalnessMap&&(this.defines.USE_METALNESSMAP=""),i.envMap)){this.defines.USE_ENVMAP="";var r="ENVMAP_TYPE_CUBE",a="ENVMAP_MODE_REFLECTION",o="ENVMAP_BLENDING_MULTIPLY";switch(i.envMap.mapping){case n.CubeReflectionMapping:case n.CubeRefractionMapping:r="ENVMAP_TYPE_CUBE";break;case n.CubeUVReflectionMapping:case n.CubeUVRefractionMapping:r="ENVMAP_TYPE_CUBE_UV";break;case n.EquirectangularReflectionMapping:case n.EquirectangularRefractionMapping:r="ENVMAP_TYPE_EQUIREC";break;case n.SphericalReflectionMapping:r="ENVMAP_TYPE_SPHERE"}switch(i.envMap.mapping){case n.CubeRefractionMapping:case n.EquirectangularRefractionMapping:a="ENVMAP_MODE_REFRACTION"}switch(i.combine){case n.MixOperation:o="ENVMAP_BLENDING_MIX";break;case n.AddOperation:o="ENVMAP_BLENDING_ADD";break;case n.MultiplyOperation:default:o="ENVMAP_BLENDING_MULTIPLY"}this.defines[r]="",this.defines[o]="",this.defines[a]=""}}function i(e){this.varyingParameters=[],this.vertexParameters=[],this.vertexFunctions=[],this.vertexInit=[],this.vertexNormal=[],this.vertexPosition=[],this.vertexColor=[],this.fragmentFunctions=[],this.fragmentParameters=[],this.fragmentInit=[],this.fragmentMap=[],this.fragmentDiffuse=[],t.call(this,e,n.ShaderLib.basic.uniforms),this.lights=!1,this.vertexShader=this.concatVertexShader(),this.fragmentShader=this.concatFragmentShader()}function r(e){this.varyingParameters=[],this.vertexFunctions=[],this.vertexParameters=[],this.vertexInit=[],this.vertexNormal=[],this.vertexPosition=[],this.vertexColor=[],this.fragmentFunctions=[],this.fragmentParameters=[],this.fragmentInit=[],this.fragmentMap=[],this.fragmentDiffuse=[],this.fragmentEmissive=[],this.fragmentSpecular=[],t.call(this,e,n.ShaderLib.lambert.uniforms),this.lights=!0,this.vertexShader=this.concatVertexShader(),this.fragmentShader=this.concatFragmentShader()}function a(e){this.varyingParameters=[],this.vertexFunctions=[],this.vertexParameters=[],this.vertexInit=[],this.vertexNormal=[],this.vertexPosition=[],this.vertexColor=[],this.fragmentFunctions=[],this.fragmentParameters=[],this.fragmentInit=[],this.fragmentMap=[],this.fragmentDiffuse=[],this.fragmentEmissive=[],this.fragmentSpecular=[],t.call(this,e,n.ShaderLib.phong.uniforms),this.lights=!0,this.vertexShader=this.concatVertexShader(),this.fragmentShader=this.concatFragmentShader()}function o(e){this.varyingParameters=[],this.vertexFunctions=[],this.vertexParameters=[],this.vertexInit=[],this.vertexNormal=[],this.vertexPosition=[],this.vertexColor=[],this.fragmentFunctions=[],this.fragmentParameters=[],this.fragmentInit=[],this.fragmentMap=[],this.fragmentDiffuse=[],this.fragmentRoughness=[],this.fragmentMetalness=[],this.fragmentEmissive=[],t.call(this,e,n.ShaderLib.standard.uniforms),this.lights=!0,this.vertexShader=this.concatVertexShader(),this.fragmentShader=this.concatFragmentShader()}function s(e){this.varyingParameters=[],this.vertexFunctions=[],this.vertexParameters=[],this.vertexInit=[],this.vertexPosition=[],this.vertexColor=[],this.fragmentFunctions=[],this.fragmentParameters=[],this.fragmentInit=[],this.fragmentMap=[],this.fragmentDiffuse=[],this.fragmentShape=[],t.call(this,e,n.ShaderLib.points.uniforms),this.vertexShader=this.concatVertexShader(),this.fragmentShader=this.concatFragmentShader()}function f(e){this.depthPacking=n.RGBADepthPacking,this.clipping=!0,this.vertexFunctions=[],this.vertexParameters=[],this.vertexInit=[],this.vertexPosition=[],t.call(this,e),this.uniforms=n.UniformsUtils.merge([n.ShaderLib.depth.uniforms,this.uniforms]),this.vertexShader=this.concatVertexShader(),this.fragmentShader=n.ShaderLib.depth.fragmentShader}function l(e){this.depthPacking=n.RGBADepthPacking,this.clipping=!0,this.vertexFunctions=[],this.vertexParameters=[],this.vertexInit=[],this.vertexPosition=[],t.call(this,e),this.uniforms=n.UniformsUtils.merge([n.ShaderLib.distanceRGBA.uniforms,this.uniforms]),this.vertexShader=this.concatVertexShader(),this.fragmentShader=n.ShaderLib.distanceRGBA.fragmentShader}function c(e,t){n.BufferGeometry.call(this),this.prefabGeometry=e,this.isPrefabBufferGeometry=e.isBufferGeometry,this.prefabCount=t,this.isPrefabBufferGeometry?this.prefabVertexCount=e.attributes.position.count:this.prefabVertexCount=e.vertices.length,this.bufferIndices(),this.bufferPositions()}function u(e,t){n.BufferGeometry.call(this),Array.isArray(e)?this.prefabGeometries=e:this.prefabGeometries=[e],this.prefabGeometriesCount=this.prefabGeometries.length,this.prefabCount=t*this.prefabGeometriesCount,this.repeatCount=t,this.prefabVertexCounts=this.prefabGeometries.map(function(e){return e.isBufferGeometry?e.attributes.position.count:e.vertices.length}),this.repeatVertexCount=this.prefabVertexCounts.reduce(function(e,n){return e+n},0),this.bufferIndices(),this.bufferPositions()}function p(e,t){n.BufferGeometry.call(this),this.modelGeometry=e,this.faceCount=this.modelGeometry.faces.length,this.vertexCount=this.modelGeometry.vertices.length,(t=t||{}).computeCentroids&&this.computeCentroids(),this.bufferIndices(),this.bufferPositions(t.localizeFaces)}function d(e){n.BufferGeometry.call(this),this.pointCount=e,this.bufferPositions()}function m(e,n,t,i,r){this.key=e,this.start=n,this.duration=t,this.transition=i,this.compiler=r,this.trail=0}function h(){this.duration=0,this.timeKey="tTime",this.segments={},this.__key=0}t.prototype=Object.assign(Object.create(n.ShaderMaterial.prototype),{constructor:t,setUniformValues:function(e){var n=this;if(e){Object.keys(e).forEach(function(t){t in n.uniforms&&(n.uniforms[t].value=e[t])})}},stringifyChunk:function(e){return this[e]?"string"==typeof this[e]?this[e]:this[e].join("\n"):""}}),(i.prototype=Object.create(t.prototype)).constructor=i,i.prototype.concatVertexShader=function(){return"\n  #include <common>\n  #include <uv_pars_vertex>\n  #include <uv2_pars_vertex>\n  #include <envmap_pars_vertex>\n  #include <color_pars_vertex>\n  #include <fog_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  "+this.stringifyChunk("vertexParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("vertexFunctions")+"\n  \n  void main() {\n\n    "+this.stringifyChunk("vertexInit")+"\n  \n    #include <uv_vertex>\n    #include <uv2_vertex>\n    #include <color_vertex>\n    #include <skinbase_vertex>\n  \n    #ifdef USE_ENVMAP\n  \n    #include <beginnormal_vertex>\n    \n    "+this.stringifyChunk("vertexNormal")+"\n    \n    #include <morphnormal_vertex>\n    #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n  \n    #endif\n  \n    #include <begin_vertex>\n    \n    "+this.stringifyChunk("vertexPosition")+"\n    "+this.stringifyChunk("vertexColor")+"\n    \n    #include <morphtarget_vertex>\n    #include <skinning_vertex>\n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n  \n    #include <worldpos_vertex>\n    #include <clipping_planes_vertex>\n    #include <envmap_vertex>\n    #include <fog_vertex>\n  }"},i.prototype.concatFragmentShader=function(){return"\n  uniform vec3 diffuse;\n  uniform float opacity;\n  \n  "+this.stringifyChunk("fragmentParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("fragmentFunctions")+"\n  \n  #ifndef FLAT_SHADED\n  \n    varying vec3 vNormal;\n  \n  #endif\n  \n  #include <common>\n  #include <color_pars_fragment>\n  #include <uv_pars_fragment>\n  #include <uv2_pars_fragment>\n  #include <map_pars_fragment>\n  #include <alphamap_pars_fragment>\n  #include <aomap_pars_fragment>\n  #include <lightmap_pars_fragment>\n  #include <envmap_pars_fragment>\n  #include <fog_pars_fragment>\n  #include <specularmap_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n  \n  void main() {\n  \n    "+this.stringifyChunk("fragmentInit")+"\n  \n    #include <clipping_planes_fragment>\n\n    vec4 diffuseColor = vec4( diffuse, opacity );\n\n    "+this.stringifyChunk("fragmentDiffuse")+"\n  \n    #include <logdepthbuf_fragment>\n    \n    "+(this.stringifyChunk("fragmentMap")||"#include <map_fragment>")+"\n    \n    #include <color_fragment>\n    #include <alphamap_fragment>\n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n  \n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n  \n    // accumulation (baked indirect lighting only)\n    #ifdef USE_LIGHTMAP\n  \n      reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n  \n    #else\n  \n      reflectedLight.indirectDiffuse += vec3( 1.0 );\n  \n    #endif\n  \n    // modulation\n    #include <aomap_fragment>\n  \n    reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n  \n    vec3 outgoingLight = reflectedLight.indirectDiffuse;\n  \n    #include <envmap_fragment>\n  \n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n  \n    #include <premultiplied_alpha_fragment>\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n  }"},(r.prototype=Object.create(t.prototype)).constructor=r,r.prototype.concatVertexShader=function(){return"\n  #define LAMBERT\n\n  varying vec3 vLightFront;\n  \n  #ifdef DOUBLE_SIDED\n  \n    varying vec3 vLightBack;\n  \n  #endif\n  \n  #include <common>\n  #include <uv_pars_vertex>\n  #include <uv2_pars_vertex>\n  #include <envmap_pars_vertex>\n  #include <bsdfs>\n  #include <lights_pars>\n  #include <color_pars_vertex>\n  #include <fog_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <shadowmap_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  "+this.stringifyChunk("vertexParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("vertexFunctions")+"\n  \n  void main() {\n  \n    "+this.stringifyChunk("vertexInit")+"\n  \n    #include <uv_vertex>\n    #include <uv2_vertex>\n    #include <color_vertex>\n  \n    #include <beginnormal_vertex>\n    \n    "+this.stringifyChunk("vertexNormal")+"\n    \n    #include <morphnormal_vertex>\n    #include <skinbase_vertex>\n    #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n  \n    #include <begin_vertex>\n    \n    "+this.stringifyChunk("vertexPosition")+"\n    "+this.stringifyChunk("vertexColor")+"\n    \n    #include <morphtarget_vertex>\n    #include <skinning_vertex>\n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n  \n    #include <worldpos_vertex>\n    #include <envmap_vertex>\n    #include <lights_lambert_vertex>\n    #include <shadowmap_vertex>\n    #include <fog_vertex>\n  }"},r.prototype.concatFragmentShader=function(){return"\n  uniform vec3 diffuse;\n  uniform vec3 emissive;\n  uniform float opacity;\n  \n  varying vec3 vLightFront;\n  \n  #ifdef DOUBLE_SIDED\n  \n    varying vec3 vLightBack;\n  \n  #endif\n  \n  #include <common>\n  #include <packing>\n  #include <dithering_pars_fragment>\n  #include <color_pars_fragment>\n  #include <uv_pars_fragment>\n  #include <uv2_pars_fragment>\n  #include <map_pars_fragment>\n  #include <alphamap_pars_fragment>\n  #include <aomap_pars_fragment>\n  #include <lightmap_pars_fragment>\n  #include <emissivemap_pars_fragment>\n  #include <envmap_pars_fragment>\n  #include <bsdfs>\n  #include <lights_pars>\n  #include <fog_pars_fragment>\n  #include <shadowmap_pars_fragment>\n  #include <shadowmask_pars_fragment>\n  #include <specularmap_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n  \n  "+this.stringifyChunk("fragmentParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("fragmentFunctions")+"\n  \n  void main() {\n  \n    "+this.stringifyChunk("fragmentInit")+"\n  \n    #include <clipping_planes_fragment>\n\n    vec4 diffuseColor = vec4( diffuse, opacity );\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    vec3 totalEmissiveRadiance = emissive;\n\t\n    "+this.stringifyChunk("fragmentDiffuse")+"\n  \n    #include <logdepthbuf_fragment>\n\n    "+(this.stringifyChunk("fragmentMap")||"#include <map_fragment>")+"\n\n    #include <color_fragment>\n    #include <alphamap_fragment>\n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n\n    "+this.stringifyChunk("fragmentEmissive")+"\n\n    #include <emissivemap_fragment>\n  \n    // accumulation\n    reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n  \n    #include <lightmap_fragment>\n  \n    reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n  \n    #ifdef DOUBLE_SIDED\n  \n      reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n  \n    #else\n  \n      reflectedLight.directDiffuse = vLightFront;\n  \n    #endif\n  \n    reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n  \n    // modulation\n    #include <aomap_fragment>\n  \n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n  \n    #include <envmap_fragment>\n  \n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n  \n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n  }"},(a.prototype=Object.create(t.prototype)).constructor=a,a.prototype.concatVertexShader=function(){return"\n  #define PHONG\n\n  varying vec3 vViewPosition;\n  \n  #ifndef FLAT_SHADED\n  \n    varying vec3 vNormal;\n  \n  #endif\n  \n  #include <common>\n  #include <uv_pars_vertex>\n  #include <uv2_pars_vertex>\n  #include <displacementmap_pars_vertex>\n  #include <envmap_pars_vertex>\n  #include <color_pars_vertex>\n  #include <fog_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <shadowmap_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  "+this.stringifyChunk("vertexParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("vertexFunctions")+"\n  \n  void main() {\n  \n    "+this.stringifyChunk("vertexInit")+"\n  \n    #include <uv_vertex>\n    #include <uv2_vertex>\n    #include <color_vertex>\n  \n    #include <beginnormal_vertex>\n    \n    "+this.stringifyChunk("vertexNormal")+"\n    \n    #include <morphnormal_vertex>\n    #include <skinbase_vertex>\n    #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n  \n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n  \n    vNormal = normalize( transformedNormal );\n  \n  #endif\n  \n    #include <begin_vertex>\n    \n    "+this.stringifyChunk("vertexPosition")+"\n    "+this.stringifyChunk("vertexColor")+"\n    \n    #include <morphtarget_vertex>\n    #include <skinning_vertex>\n    #include <displacementmap_vertex>\n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n  \n    vViewPosition = - mvPosition.xyz;\n  \n    #include <worldpos_vertex>\n    #include <envmap_vertex>\n    #include <shadowmap_vertex>\n    #include <fog_vertex>\n  }"},a.prototype.concatFragmentShader=function(){return"\n  #define PHONG\n\n  uniform vec3 diffuse;\n  uniform vec3 emissive;\n  uniform vec3 specular;\n  uniform float shininess;\n  uniform float opacity;\n  \n  #include <common>\n  #include <packing>\n  #include <dithering_pars_fragment>\n  #include <color_pars_fragment>\n  #include <uv_pars_fragment>\n  #include <uv2_pars_fragment>\n  #include <map_pars_fragment>\n  #include <alphamap_pars_fragment>\n  #include <aomap_pars_fragment>\n  #include <lightmap_pars_fragment>\n  #include <emissivemap_pars_fragment>\n  #include <envmap_pars_fragment>\n  #include <gradientmap_pars_fragment>\n  #include <fog_pars_fragment>\n  #include <bsdfs>\n  #include <lights_pars>\n  #include <lights_phong_pars_fragment>\n  #include <shadowmap_pars_fragment>\n  #include <bumpmap_pars_fragment>\n  #include <normalmap_pars_fragment>\n  #include <specularmap_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n  \n  "+this.stringifyChunk("fragmentParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("fragmentFunctions")+"\n  \n  void main() {\n  \n    "+this.stringifyChunk("fragmentInit")+"\n  \n    #include <clipping_planes_fragment>\n  \n    vec4 diffuseColor = vec4( diffuse, opacity );\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    vec3 totalEmissiveRadiance = emissive;\n  \n    "+this.stringifyChunk("fragmentDiffuse")+"\n  \n    #include <logdepthbuf_fragment>\n\n    "+(this.stringifyChunk("fragmentMap")||"#include <map_fragment>")+"\n\n    #include <color_fragment>\n    #include <alphamap_fragment>\n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n    #include <normal_fragment>\n    \n    "+this.stringifyChunk("fragmentEmissive")+"\n    \n    #include <emissivemap_fragment>\n  \n    // accumulation\n    #include <lights_phong_fragment>\n    \n    "+this.stringifyChunk("fragmentSpecular")+"\n    \n    #include <lights_template>\n  \n    // modulation\n    #include <aomap_fragment>\n  \n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n  \n    #include <envmap_fragment>\n  \n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n  \n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n  \n  }"},(o.prototype=Object.create(t.prototype)).constructor=o,o.prototype.concatVertexShader=function(){return"\n  #define PHYSICAL\n\n  varying vec3 vViewPosition;\n  \n  #ifndef FLAT_SHADED\n  \n    varying vec3 vNormal;\n  \n  #endif\n  \n  #include <common>\n  #include <uv_pars_vertex>\n  #include <uv2_pars_vertex>\n  #include <displacementmap_pars_vertex>\n  #include <color_pars_vertex>\n  #include <fog_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <shadowmap_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  "+this.stringifyChunk("vertexParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("vertexFunctions")+"\n  \n  void main() {\n\n    "+this.stringifyChunk("vertexInit")+"\n\n    #include <uv_vertex>\n    #include <uv2_vertex>\n    #include <color_vertex>\n  \n    #include <beginnormal_vertex>\n    \n    "+this.stringifyChunk("vertexNormal")+"\n    \n    #include <morphnormal_vertex>\n    #include <skinbase_vertex>\n    #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n  \n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n  \n    vNormal = normalize( transformedNormal );\n  \n  #endif\n  \n    #include <begin_vertex>\n    \n    "+this.stringifyChunk("vertexPosition")+"\n    "+this.stringifyChunk("vertexColor")+"\n    \n    #include <morphtarget_vertex>\n    #include <skinning_vertex>\n    #include <displacementmap_vertex>\n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n  \n    vViewPosition = - mvPosition.xyz;\n  \n    #include <worldpos_vertex>\n    #include <shadowmap_vertex>\n    #include <fog_vertex>\n  }"},o.prototype.concatFragmentShader=function(){return"\n  #define PHYSICAL\n  \n  uniform vec3 diffuse;\n  uniform vec3 emissive;\n  uniform float roughness;\n  uniform float metalness;\n  uniform float opacity;\n  \n  #ifndef STANDARD\n    uniform float clearCoat;\n    uniform float clearCoatRoughness;\n  #endif\n  \n  varying vec3 vViewPosition;\n  \n  #ifndef FLAT_SHADED\n  \n    varying vec3 vNormal;\n  \n  #endif\n  \n  #include <common>\n  #include <packing>\n  #include <dithering_pars_fragment>\n  #include <color_pars_fragment>\n  #include <uv_pars_fragment>\n  #include <uv2_pars_fragment>\n  #include <map_pars_fragment>\n  #include <alphamap_pars_fragment>\n  #include <aomap_pars_fragment>\n  #include <lightmap_pars_fragment>\n  #include <emissivemap_pars_fragment>\n  #include <envmap_pars_fragment>\n  #include <fog_pars_fragment>\n  #include <bsdfs>\n  #include <cube_uv_reflection_fragment>\n  #include <lights_pars>\n  #include <lights_physical_pars_fragment>\n  #include <shadowmap_pars_fragment>\n  #include <bumpmap_pars_fragment>\n  #include <normalmap_pars_fragment>\n  #include <roughnessmap_pars_fragment>\n  #include <metalnessmap_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n  \n  "+this.stringifyChunk("fragmentParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("fragmentFunctions")+"\n  \n  void main() {\n  \n    "+this.stringifyChunk("fragmentInit")+"\n  \n    #include <clipping_planes_fragment>\n  \n    vec4 diffuseColor = vec4( diffuse, opacity );\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    vec3 totalEmissiveRadiance = emissive;\n  \n    "+this.stringifyChunk("fragmentDiffuse")+"\n  \n    #include <logdepthbuf_fragment>\n\n    "+(this.stringifyChunk("fragmentMap")||"#include <map_fragment>")+"\n\n    #include <color_fragment>\n    #include <alphamap_fragment>\n    #include <alphatest_fragment>\n    \n    float roughnessFactor = roughness;\n    "+this.stringifyChunk("fragmentRoughness")+"\n    #ifdef USE_ROUGHNESSMAP\n    \n      vec4 texelRoughness = texture2D( roughnessMap, vUv );\n    \n      // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n      roughnessFactor *= texelRoughness.g;\n    \n    #endif\n    \n    float metalnessFactor = metalness;\n    "+this.stringifyChunk("fragmentMetalness")+"\n    #ifdef USE_METALNESSMAP\n    \n      vec4 texelMetalness = texture2D( metalnessMap, vUv );\n      metalnessFactor *= texelMetalness.b;\n    \n    #endif\n    \n    #include <normal_fragment>\n    \n    "+this.stringifyChunk("fragmentEmissive")+"\n    \n    #include <emissivemap_fragment>\n  \n    // accumulation\n    #include <lights_physical_fragment>\n    #include <lights_template>\n  \n    // modulation\n    #include <aomap_fragment>\n  \n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n  \n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n  \n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n  \n  }"},(s.prototype=Object.create(t.prototype)).constructor=s,s.prototype.concatVertexShader=function(){return"\n  uniform float size;\n  uniform float scale;\n  \n  #include <common>\n  #include <color_pars_vertex>\n  #include <fog_pars_vertex>\n  #include <shadowmap_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  "+this.stringifyChunk("vertexParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("vertexFunctions")+"\n  \n  void main() {\n  \n    "+this.stringifyChunk("vertexInit")+"\n  \n    #include <color_vertex>\n    #include <begin_vertex>\n    \n    "+this.stringifyChunk("vertexPosition")+"\n    "+this.stringifyChunk("vertexColor")+"\n    \n    #include <project_vertex>\n  \n    #ifdef USE_SIZEATTENUATION\n      gl_PointSize = size * ( scale / - mvPosition.z );\n    #else\n      gl_PointSize = size;\n    #endif\n  \n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n    #include <worldpos_vertex>\n    #include <shadowmap_vertex>\n    #include <fog_vertex>\n  }"},s.prototype.concatFragmentShader=function(){return"\n  uniform vec3 diffuse;\n  uniform float opacity;\n  \n  #include <common>\n  #include <packing>\n  #include <color_pars_fragment>\n  #include <map_particle_pars_fragment>\n  #include <fog_pars_fragment>\n  #include <shadowmap_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n  \n  "+this.stringifyChunk("fragmentParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("fragmentFunctions")+"\n  \n  void main() {\n  \n    "+this.stringifyChunk("fragmentInit")+"\n  \n    #include <clipping_planes_fragment>\n  \n    vec3 outgoingLight = vec3( 0.0 );\n    vec4 diffuseColor = vec4( diffuse, opacity );\n  \n    "+this.stringifyChunk("fragmentDiffuse")+"\n  \n    #include <logdepthbuf_fragment>\n\n    "+(this.stringifyChunk("fragmentMap")||"#include <map_particle_fragment>")+"\n\n    #include <color_fragment>\n    #include <alphatest_fragment>\n  \n    outgoingLight = diffuseColor.rgb;\n  \n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    \n    "+this.stringifyChunk("fragmentShape")+"\n  \n    #include <premultiplied_alpha_fragment>\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n  }"},(f.prototype=Object.create(t.prototype)).constructor=f,f.prototype.concatVertexShader=function(){return"\n  #include <common>\n  #include <uv_pars_vertex>\n  #include <displacementmap_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  "+this.stringifyChunk("vertexParameters")+"\n  "+this.stringifyChunk("vertexFunctions")+"\n  \n  void main() {\n  \n    "+this.stringifyChunk("vertexInit")+"\n  \n    #include <uv_vertex>\n  \n    #include <skinbase_vertex>\n  \n    #ifdef USE_DISPLACEMENTMAP\n  \n      #include <beginnormal_vertex>\n      #include <morphnormal_vertex>\n      #include <skinnormal_vertex>\n  \n    #endif\n  \n    #include <begin_vertex>\n    \n    "+this.stringifyChunk("vertexPosition")+"\n\n    #include <morphtarget_vertex>\n    #include <skinning_vertex>\n    #include <displacementmap_vertex>\n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n  }"},(l.prototype=Object.create(t.prototype)).constructor=l,l.prototype.concatVertexShader=function(){return"\n  #define DISTANCE\n\n  varying vec3 vWorldPosition;\n  \n  #include <common>\n  #include <uv_pars_vertex>\n  #include <displacementmap_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  "+this.stringifyChunk("vertexParameters")+"\n  "+this.stringifyChunk("vertexFunctions")+"\n  \n  void main() {\n\n    "+this.stringifyChunk("vertexInit")+"\n  \n    #include <uv_vertex>\n  \n    #include <skinbase_vertex>\n  \n    #ifdef USE_DISPLACEMENTMAP\n  \n      #include <beginnormal_vertex>\n      #include <morphnormal_vertex>\n      #include <skinnormal_vertex>\n  \n    #endif\n  \n    #include <begin_vertex>\n    \n    "+this.stringifyChunk("vertexPosition")+"\n\n    #include <morphtarget_vertex>\n    #include <skinning_vertex>\n    #include <displacementmap_vertex>\n    #include <project_vertex>\n    #include <worldpos_vertex>\n    #include <clipping_planes_vertex>\n  \n    vWorldPosition = worldPosition.xyz;\n  \n  }"},(c.prototype=Object.create(n.BufferGeometry.prototype)).constructor=c,c.prototype.bufferIndices=function(){var e=[],t=void 0;if(this.isPrefabBufferGeometry)if(this.prefabGeometry.index)t=this.prefabGeometry.index.count,e=this.prefabGeometry.index.array;else{t=this.prefabVertexCount;for(var i=0;i<t;i++)e.push(i)}else{var r=this.prefabGeometry.faces.length;t=3*r;for(var a=0;a<r;a++){var o=this.prefabGeometry.faces[a];e.push(o.a,o.b,o.c)}}var s=new Uint32Array(this.prefabCount*t);this.setIndex(new n.BufferAttribute(s,1));for(var f=0;f<this.prefabCount;f++)for(var l=0;l<t;l++)s[f*t+l]=e[l]+f*this.prefabVertexCount},c.prototype.bufferPositions=function(){var e=this.createAttribute("position",3).array;if(this.isPrefabBufferGeometry)for(var n=this.prefabGeometry.attributes.position.array,t=0,i=0;t<this.prefabCount;t++)for(var r=0;r<this.prefabVertexCount;r++,i+=3)e[i]=n[3*r],e[i+1]=n[3*r+1],e[i+2]=n[3*r+2];else for(var a=0,o=0;a<this.prefabCount;a++)for(var s=0;s<this.prefabVertexCount;s++,o+=3){var f=this.prefabGeometry.vertices[s];e[o]=f.x,e[o+1]=f.y,e[o+2]=f.z}},c.prototype.bufferUvs=function(){for(var e=[],t=this.isPrefabBufferGeometry?this.prefabGeometry.attributes.uv.array:this.prefabGeometry.faceVertexUvs[0],i=0;i<this.prefabVertexCount;i++)e.push(new n.Vector2(t[2*i],t[2*i+1]));for(var r=this.createAttribute("uv",2),a=0,o=0;a<this.prefabCount;a++)for(var s=0;s<this.prefabVertexCount;s++,o+=2){var f=e[s];r.array[o]=f.x,r.array[o+1]=f.y}},c.prototype.createAttribute=function(e,t,i){var r=new Float32Array(this.prefabCount*this.prefabVertexCount*t),a=new n.BufferAttribute(r,t);if(this.addAttribute(e,a),i)for(var o=[],s=0;s<this.prefabCount;s++)i(o,s,this.prefabCount),this.setPrefabData(a,s,o);return a},c.prototype.setPrefabData=function(e,n,t){e="string"==typeof e?this.attributes[e]:e;for(var i=n*this.prefabVertexCount*e.itemSize,r=0;r<this.prefabVertexCount;r++)for(var a=0;a<e.itemSize;a++)e.array[i++]=t[a]},(u.prototype=Object.create(n.BufferGeometry.prototype)).constructor=u,u.prototype.bufferIndices=function(){for(var e=0,t=this.prefabGeometries.map(function(n){var t=[];if(n.isBufferGeometry)if(n.index)t=n.index.array;else for(var i=0;i<n.attributes.position.count;i++)t.push(i);else for(var r=0;r<n.faces.length;r++){var a=n.faces[r];t.push(a.a,a.b,a.c)}return e+=t.length,t}),i=new Uint32Array(e*this.repeatCount),r=0,a=0,o=0;o<this.prefabCount;o++){for(var s=o%this.prefabGeometriesCount,f=t[s],l=this.prefabVertexCounts[s],c=0;c<f.length;c++)i[r++]=f[c]+a;a+=l}this.setIndex(new n.BufferAttribute(i,1))},u.prototype.bufferPositions=function(){for(var e=this,t=this.createAttribute("position",3).array,i=this.prefabGeometries.map(function(t,i){var r=void 0;if(t.isBufferGeometry)r=t.attributes.position.array;else{var a=e.prefabVertexCounts[i];r=[];for(var o=0,s=0;o<a;o++){var f=t.vertices[o];r[s++]=f.x,r[s++]=f.y,r[s++]=f.z}}return r}),r=0,a=0;r<this.prefabCount;r++)for(var o=r%this.prefabGeometries.length,s=this.prefabVertexCounts[o],f=i[o],l=0;l<s;l++)t[a++]=f[3*l],t[a++]=f[3*l+1],t[a++]=f[3*l+2]},u.prototype.bufferUvs=function(){for(var e=this,t=this.createAttribute("uv",2).array,i=this.prefabGeometries.map(function(t,i){var r=void 0;if(t.isBufferGeometry)t.attributes.uv||console.error("No UV found in prefab geometry",t),r=t.attributes.uv.array;else{for(var a=e.prefabIndices[i].length/3,o=[],s=0;s<a;s++){var f=t.faces[s],l=t.faceVertexUvs[0][s];o[f.a]=l[0],o[f.b]=l[1],o[f.c]=l[2]}r=[];for(var c=0;c<o.length;c++)r[2*c]=o[c].x,r[2*c+1]=o[c].y}return r}),r=0,a=0;r<this.prefabCount;r++)for(var o=r%this.prefabGeometries.length,s=this.prefabVertexCounts[o],f=i[o],l=0;l<s;l++)t[a++]=f[2*l],t[a++]=f[2*l+1]},u.prototype.createAttribute=function(e,t,i){var r=new Float32Array(this.repeatCount*this.repeatVertexCount*t),a=new n.BufferAttribute(r,t);if(this.addAttribute(e,a),i)for(var o=[],s=0;s<this.prefabCount;s++)i(o,s,this.prefabCount),this.setPrefabData(a,s,o);return a},u.prototype.setPrefabData=function(e,t,i){e="string"==typeof e?this.attributes[e]:e;for(var r=t%this.prefabGeometriesCount,a=this.prefabVertexCounts[r],o=(t/this.prefabGeometriesCount|0)*this.prefabGeometriesCount,s=o*this.repeatVertexCount,f=t-o,l=0,c=0;l<f;)c+=this.prefabVertexCounts[l++];for(var u=(s+c)*e.itemSize,p=0;p<a;p++)for(var d=0;d<e.itemSize;d++)e.array[u++]=i[d]};var v={separateFaces:function(e){for(var n=[],t=0,i=e.faces.length;t<i;t++){var r=n.length,a=e.faces[t],o=a.a,s=a.b,f=a.c,l=e.vertices[o],c=e.vertices[s],u=e.vertices[f];n.push(l.clone()),n.push(c.clone()),n.push(u.clone()),a.a=r,a.b=r+1,a.c=r+2}e.vertices=n},computeCentroid:function(e,t,i){var r=e.vertices[t.a],a=e.vertices[t.b],o=e.vertices[t.c];return i=i||new n.Vector3,i.x=(r.x+a.x+o.x)/3,i.y=(r.y+a.y+o.y)/3,i.z=(r.z+a.z+o.z)/3,i},randomInBox:function(e,t){return t=t||new n.Vector3,t.x=n.Math.randFloat(e.min.x,e.max.x),t.y=n.Math.randFloat(e.min.y,e.max.y),t.z=n.Math.randFloat(e.min.z,e.max.z),t},randomAxis:function(e){return e=e||new n.Vector3,e.x=n.Math.randFloatSpread(2),e.y=n.Math.randFloatSpread(2),e.z=n.Math.randFloatSpread(2),e.normalize(),e},createDepthAnimationMaterial:function(e){return new f({uniforms:e.uniforms,defines:e.defines,vertexFunctions:e.vertexFunctions,vertexParameters:e.vertexParameters,vertexInit:e.vertexInit,vertexPosition:e.vertexPosition})},createDistanceAnimationMaterial:function(e){return new l({uniforms:e.uniforms,defines:e.defines,vertexFunctions:e.vertexFunctions,vertexParameters:e.vertexParameters,vertexInit:e.vertexInit,vertexPosition:e.vertexPosition})}};(p.prototype=Object.create(n.BufferGeometry.prototype)).constructor=p,p.prototype.computeCentroids=function(){this.centroids=[];for(var e=0;e<this.faceCount;e++)this.centroids[e]=v.computeCentroid(this.modelGeometry,this.modelGeometry.faces[e])},p.prototype.bufferIndices=function(){var e=new Uint32Array(3*this.faceCount);this.setIndex(new n.BufferAttribute(e,1));for(var t=0,i=0;t<this.faceCount;t++,i+=3){var r=this.modelGeometry.faces[t];e[i]=r.a,e[i+1]=r.b,e[i+2]=r.c}},p.prototype.bufferPositions=function(e){var t=this.createAttribute("position",3).array,i=void 0,r=void 0;if(!0===e)for(i=0;i<this.faceCount;i++){var a=this.modelGeometry.faces[i],o=this.centroids?this.centroids[i]:v.computeCentroid(this.modelGeometry,a),s=this.modelGeometry.vertices[a.a],f=this.modelGeometry.vertices[a.b],l=this.modelGeometry.vertices[a.c];t[3*a.a]=s.x-o.x,t[3*a.a+1]=s.y-o.y,t[3*a.a+2]=s.z-o.z,t[3*a.b]=f.x-o.x,t[3*a.b+1]=f.y-o.y,t[3*a.b+2]=f.z-o.z,t[3*a.c]=l.x-o.x,t[3*a.c+1]=l.y-o.y,t[3*a.c+2]=l.z-o.z}else for(i=0,r=0;i<this.vertexCount;i++,r+=3){var c=this.modelGeometry.vertices[i];t[r]=c.x,t[r+1]=c.y,t[r+2]=c.z}},p.prototype.bufferUVs=function(){for(var e=this.createAttribute("uv",2).array,t=0;t<this.faceCount;t++){var i=this.modelGeometry.faces[t],r=void 0;r=this.modelGeometry.faceVertexUvs[0][t][0],e[2*i.a]=r.x,e[2*i.a+1]=r.y,r=this.modelGeometry.faceVertexUvs[0][t][1],e[2*i.b]=r.x,e[2*i.b+1]=r.y,r=this.modelGeometry.faceVertexUvs[0][t][2],e[2*i.c]=r.x,e[2*i.c+1]=r.y}},p.prototype.createAttribute=function(e,t,i){var r=new Float32Array(this.vertexCount*t),a=new n.BufferAttribute(r,t);if(this.addAttribute(e,a),i)for(var o=[],s=0;s<this.faceCount;s++)i(o,s,this.faceCount),this.setFaceData(r,s,o);return a},p.prototype.setFaceData=function(e,t,i){for(var r=3*t*(e="string"==typeof e?this.attributes[e]:e).itemSize,a=0;a<3;a++)for(var o=0;o<e.itemSize;o++)e.array[r++]=i[o]},(d.prototype=Object.create(n.BufferGeometry.prototype)).constructor=d,d.prototype.bufferPositions=function(){this.createAttribute("position",3)},d.prototype.createAttribute=function(e,t,i){var r=new Float32Array(this.pointCount*t),a=new n.BufferAttribute(r,t);if(this.addAttribute(e,a),i)for(var o=[],s=0;s<this.pointCount;s++)i(o,s,this.pointCount),this.setPointData(a,s,o);return a},d.prototype.setPointData=function(e,t,i){for(var r=t*(e="string"==typeof e?this.attributes[e]:e).itemSize,a=0;a<e.itemSize;a++)e.array[r++]=i[a]};var g={catmull_rom_spline:"vec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, vec2 c) {\n    vec4 v0 = (p2 - p0) * c.x;\n    vec4 v1 = (p3 - p1) * c.y;\n    float t2 = t * t;\n    float t3 = t * t * t;\n    return vec4((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\nvec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t) {\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n}\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t, vec2 c) {\n    vec3 v0 = (p2 - p0) * c.x;\n    vec3 v1 = (p3 - p1) * c.y;\n    float t2 = t * t;\n    float t3 = t * t * t;\n    return vec3((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n}\nvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t, vec2 c) {\n    vec2 v0 = (p2 - p0) * c.x;\n    vec2 v1 = (p3 - p1) * c.y;\n    float t2 = t * t;\n    float t3 = t * t * t;\n    return vec2((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\nvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n}\nfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t, vec2 c) {\n    float v0 = (p2 - p0) * c.x;\n    float v1 = (p3 - p1) * c.y;\n    float t2 = t * t;\n    float t3 = t * t * t;\n    return float((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\nfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t) {\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n}\nivec4 getCatmullRomSplineIndices(float l, float p) {\n    float index = floor(p);\n    int i0 = int(max(0.0, index - 1.0));\n    int i1 = int(index);\n    int i2 = int(min(index + 1.0, l));\n    int i3 = int(min(index + 2.0, l));\n    return ivec4(i0, i1, i2, i3);\n}\nivec4 getCatmullRomSplineIndicesClosed(float l, float p) {\n    float index = floor(p);\n    int i0 = int(index == 0.0 ? l : index - 1.0);\n    int i1 = int(index);\n    int i2 = int(mod(index + 1.0, l));\n    int i3 = int(mod(index + 2.0, l));\n    return ivec4(i0, i1, i2, i3);\n}\n",cubic_bezier:"vec3 cubicBezier(vec3 p0, vec3 c0, vec3 c1, vec3 p1, float t) {\n    float tn = 1.0 - t;\n    return tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\n}\nvec2 cubicBezier(vec2 p0, vec2 c0, vec2 c1, vec2 p1, float t) {\n    float tn = 1.0 - t;\n    return tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\n}\n",ease_back_in:"float easeBackIn(float p, float amplitude) {\n    return p * p * ((amplitude + 1.0) * p - amplitude);\n}\nfloat easeBackIn(float p) {\n    return easeBackIn(p, 1.70158);\n}\nfloat easeBackIn(float t, float b, float c, float d, float amplitude) {\n    return b + easeBackIn(t / d, amplitude) * c;\n}\nfloat easeBackIn(float t, float b, float c, float d) {\n    return b + easeBackIn(t / d) * c;\n}\n",ease_back_in_out:"float easeBackInOut(float p, float amplitude) {\n    amplitude *= 1.525;\n    return ((p *= 2.0) < 1.0) ? 0.5 * p * p * ((amplitude + 1.0) * p - amplitude) : 0.5 * ((p -= 2.0) * p * ((amplitude + 1.0) * p + amplitude) + 2.0);\n}\nfloat easeBackInOut(float p) {\n    return easeBackInOut(p, 1.70158);\n}\nfloat easeBackInOut(float t, float b, float c, float d, float amplitude) {\n    return b + easeBackInOut(t / d, amplitude) * c;\n}\nfloat easeBackInOut(float t, float b, float c, float d) {\n    return b + easeBackInOut(t / d) * c;\n}\n",ease_back_out:"float easeBackOut(float p, float amplitude) {\n    return ((p = p - 1.0) * p * ((amplitude + 1.0) * p + amplitude) + 1.0);\n}\nfloat easeBackOut(float p) {\n    return easeBackOut(p, 1.70158);\n}\nfloat easeBackOut(float t, float b, float c, float d, float amplitude) {\n    return b + easeBackOut(t / d, amplitude) * c;\n}\nfloat easeBackOut(float t, float b, float c, float d) {\n    return b + easeBackOut(t / d) * c;\n}\n",ease_bezier:"float easeBezier(float p, vec4 curve) {\n    float ip = 1.0 - p;\n    return (3.0 * ip * ip * p * curve.xy + 3.0 * ip * p * p * curve.zw + p * p * p).y;\n}\nfloat easeBezier(float t, float b, float c, float d, vec4 curve) {\n    return b + easeBezier(t / d, curve) * c;\n}\n",ease_bounce_in:"float easeBounceIn(float p) {\n    if ((p = 1.0 - p) < 1.0 / 2.75) {\n        return 1.0 - (7.5625 * p * p);\n    } else if (p < 2.0 / 2.75) {\n        return 1.0 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);\n    } else if (p < 2.5 / 2.75) {\n        return 1.0 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);\n    }\n    return 1.0 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);\n}\nfloat easeBounceIn(float t, float b, float c, float d) {\n    return b + easeBounceIn(t / d) * c;\n}\n",ease_bounce_in_out:"float easeBounceInOut(float p) {\n    bool invert = (p < 0.5);\n    p = invert ? (1.0 - (p * 2.0)) : ((p * 2.0) - 1.0);\n    if (p < 1.0 / 2.75) {\n        p = 7.5625 * p * p;\n    } else if (p < 2.0 / 2.75) {\n        p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\n    } else if (p < 2.5 / 2.75) {\n        p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\n    } else {\n        p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\n    }\n    return invert ? (1.0 - p) * 0.5 : p * 0.5 + 0.5;\n}\nfloat easeBounceInOut(float t, float b, float c, float d) {\n    return b + easeBounceInOut(t / d) * c;\n}\n",ease_bounce_out:"float easeBounceOut(float p) {\n    if (p < 1.0 / 2.75) {\n        return 7.5625 * p * p;\n    } else if (p < 2.0 / 2.75) {\n        return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\n    } else if (p < 2.5 / 2.75) {\n        return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\n    }\n    return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\n}\nfloat easeBounceOut(float t, float b, float c, float d) {\n    return b + easeBounceOut(t / d) * c;\n}\n",ease_circ_in:"float easeCircIn(float p) {\n    return -(sqrt(1.0 - p * p) - 1.0);\n}\nfloat easeCircIn(float t, float b, float c, float d) {\n    return b + easeCircIn(t / d) * c;\n}\n",ease_circ_in_out:"float easeCircInOut(float p) {\n    return ((p *= 2.0) < 1.0) ? -0.5 * (sqrt(1.0 - p * p) - 1.0) : 0.5 * (sqrt(1.0 - (p -= 2.0) * p) + 1.0);\n}\nfloat easeCircInOut(float t, float b, float c, float d) {\n    return b + easeCircInOut(t / d) * c;\n}\n",ease_circ_out:"float easeCircOut(float p) {\n  return sqrt(1.0 - (p = p - 1.0) * p);\n}\nfloat easeCircOut(float t, float b, float c, float d) {\n  return b + easeCircOut(t / d) * c;\n}\n",ease_cubic_in:"float easeCubicIn(float t) {\n  return t * t * t;\n}\nfloat easeCubicIn(float t, float b, float c, float d) {\n  return b + easeCubicIn(t / d) * c;\n}\n",ease_cubic_in_out:"float easeCubicInOut(float t) {\n  return (t /= 0.5) < 1.0 ? 0.5 * t * t * t : 0.5 * ((t-=2.0) * t * t + 2.0);\n}\nfloat easeCubicInOut(float t, float b, float c, float d) {\n  return b + easeCubicInOut(t / d) * c;\n}\n",ease_cubic_out:"float easeCubicOut(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\nfloat easeCubicOut(float t, float b, float c, float d) {\n  return b + easeCubicOut(t / d) * c;\n}\n",ease_elastic_in:"float easeElasticIn(float p, float amplitude, float period) {\n    float p1 = max(amplitude, 1.0);\n    float p2 = period / min(amplitude, 1.0);\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\n    return -(p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2));\n}\nfloat easeElasticIn(float p) {\n    return easeElasticIn(p, 1.0, 0.3);\n}\nfloat easeElasticIn(float t, float b, float c, float d, float amplitude, float period) {\n    return b + easeElasticIn(t / d, amplitude, period) * c;\n}\nfloat easeElasticIn(float t, float b, float c, float d) {\n    return b + easeElasticIn(t / d) * c;\n}\n",ease_elastic_in_out:"float easeElasticInOut(float p, float amplitude, float period) {\n    float p1 = max(amplitude, 1.0);\n    float p2 = period / min(amplitude, 1.0);\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\n    return ((p *= 2.0) < 1.0) ? -0.5 * (p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2)) : p1 * pow(2.0, -10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2) * 0.5 + 1.0;\n}\nfloat easeElasticInOut(float p) {\n    return easeElasticInOut(p, 1.0, 0.3);\n}\nfloat easeElasticInOut(float t, float b, float c, float d, float amplitude, float period) {\n    return b + easeElasticInOut(t / d, amplitude, period) * c;\n}\nfloat easeElasticInOut(float t, float b, float c, float d) {\n    return b + easeElasticInOut(t / d) * c;\n}\n",ease_elastic_out:"float easeElasticOut(float p, float amplitude, float period) {\n    float p1 = max(amplitude, 1.0);\n    float p2 = period / min(amplitude, 1.0);\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\n    return p1 * pow(2.0, -10.0 * p) * sin((p - p3) * PI2 / p2) + 1.0;\n}\nfloat easeElasticOut(float p) {\n    return easeElasticOut(p, 1.0, 0.3);\n}\nfloat easeElasticOut(float t, float b, float c, float d, float amplitude, float period) {\n    return b + easeElasticOut(t / d, amplitude, period) * c;\n}\nfloat easeElasticOut(float t, float b, float c, float d) {\n    return b + easeElasticOut(t / d) * c;\n}\n",ease_expo_in:"float easeExpoIn(float p) {\n    return pow(2.0, 10.0 * (p - 1.0));\n}\nfloat easeExpoIn(float t, float b, float c, float d) {\n    return b + easeExpoIn(t / d) * c;\n}\n",ease_expo_in_out:"float easeExpoInOut(float p) {\n    return ((p *= 2.0) < 1.0) ? 0.5 * pow(2.0, 10.0 * (p - 1.0)) : 0.5 * (2.0 - pow(2.0, -10.0 * (p - 1.0)));\n}\nfloat easeExpoInOut(float t, float b, float c, float d) {\n    return b + easeExpoInOut(t / d) * c;\n}\n",ease_expo_out:"float easeExpoOut(float p) {\n  return 1.0 - pow(2.0, -10.0 * p);\n}\nfloat easeExpoOut(float t, float b, float c, float d) {\n  return b + easeExpoOut(t / d) * c;\n}\n",ease_quad_in:"float easeQuadIn(float t) {\n    return t * t;\n}\nfloat easeQuadIn(float t, float b, float c, float d) {\n  return b + easeQuadIn(t / d) * c;\n}\n",ease_quad_in_out:"float easeQuadInOut(float t) {\n    float p = 2.0 * t * t;\n    return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\nfloat easeQuadInOut(float t, float b, float c, float d) {\n    return b + easeQuadInOut(t / d) * c;\n}\n",ease_quad_out:"float easeQuadOut(float t) {\n  return -t * (t - 2.0);\n}\nfloat easeQuadOut(float t, float b, float c, float d) {\n  return b + easeQuadOut(t / d) * c;\n}\n",ease_quart_in:"float easeQuartIn(float t) {\n  return t * t * t * t;\n}\nfloat easeQuartIn(float t, float b, float c, float d) {\n  return b + easeQuartIn(t / d) * c;\n}\n",ease_quart_in_out:"float easeQuartInOut(float t) {\n    return t < 0.5 ? 8.0 * pow(t, 4.0) : -8.0 * pow(t - 1.0, 4.0) + 1.0;\n}\nfloat easeQuartInOut(float t, float b, float c, float d) {\n    return b + easeQuartInOut(t / d) * c;\n}\n",ease_quart_out:"float easeQuartOut(float t) {\n  return 1.0 - pow(1.0 - t, 4.0);\n}\nfloat easeQuartOut(float t, float b, float c, float d) {\n  return b + easeQuartOut(t / d) * c;\n}\n",ease_quint_in:"float easeQuintIn(float t) {\n    return pow(t, 5.0);\n}\nfloat easeQuintIn(float t, float b, float c, float d) {\n    return b + easeQuintIn(t / d) * c;\n}\n",ease_quint_in_out:"float easeQuintInOut(float t) {\n    return (t /= 0.5) < 1.0 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2.0) * t * t * t * t + 2.0);\n}\nfloat easeQuintInOut(float t, float b, float c, float d) {\n    return b + easeQuintInOut(t / d) * c;\n}\n",ease_quint_out:"float easeQuintOut(float t) {\n    return (t -= 1.0) * t * t * t * t + 1.0;\n}\nfloat easeQuintOut(float t, float b, float c, float d) {\n    return b + easeQuintOut(t / d) * c;\n}\n",ease_sine_in:"float easeSineIn(float p) {\n  return -cos(p * 1.57079632679) + 1.0;\n}\nfloat easeSineIn(float t, float b, float c, float d) {\n  return b + easeSineIn(t / d) * c;\n}\n",ease_sine_in_out:"float easeSineInOut(float p) {\n  return -0.5 * (cos(PI * p) - 1.0);\n}\nfloat easeSineInOut(float t, float b, float c, float d) {\n  return b + easeSineInOut(t / d) * c;\n}\n",ease_sine_out:"float easeSineOut(float p) {\n  return sin(p * 1.57079632679);\n}\nfloat easeSineOut(float t, float b, float c, float d) {\n  return b + easeSineOut(t / d) * c;\n}\n",quaternion_rotation:"vec3 rotateVector(vec4 q, vec3 v) {\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\nvec4 quatFromAxisAngle(vec3 axis, float angle) {\n    float halfAngle = angle * 0.5;\n    return vec4(axis.xyz * sin(halfAngle), cos(halfAngle));\n}\n",quaternion_slerp:"vec4 quatSlerp(vec4 q0, vec4 q1, float t) {\n    float s = 1.0 - t;\n    float c = dot(q0, q1);\n    float dir = -1.0;    float sqrSn = 1.0 - c * c;\n    if (sqrSn > 2.220446049250313e-16) {\n        float sn = sqrt(sqrSn);\n        float len = atan(sn, c * dir);\n        s = sin(s * len) / sn;\n        t = sin(t * len) / sn;\n    }\n    float tDir = t * dir;\n    return normalize(q0 * s + q1 * tDir);\n}\n"};m.prototype.compile=function(){return this.compiler(this)},Object.defineProperty(m.prototype,"end",{get:function(){return this.start+this.duration}}),h.segmentDefinitions={},h.register=function(e,n){return h.segmentDefinitions[e]=n,n},h.prototype.add=function(e,n,t){var i=eval,r=this.duration;void 0!==t?("number"==typeof t?r=t:"string"==typeof t&&i("start"+t),this.duration=Math.max(this.duration,r+e)):this.duration+=e;for(var a=Object.keys(n),o=void 0,s=0;s<a.length;s++)o=a[s],this.processTransition(o,n[o],r,e)},h.prototype.processTransition=function(e,n,t,i){var r=h.segmentDefinitions[e],a=this.segments[e];a||(a=this.segments[e]=[]),void 0===n.from&&(0===a.length?n.from=r.defaultFrom:n.from=a[a.length-1].transition.to),a.push(new m((this.__key++).toString(),t,i,n,r.compiler))},h.prototype.compile=function(){for(var e=[],n=Object.keys(this.segments),t=void 0,i=0;i<n.length;i++)t=this.segments[n[i]],this.fillGaps(t),t.forEach(function(n){e.push(n.compile())});return e},h.prototype.fillGaps=function(e){if(0!==e.length){for(var n=void 0,t=void 0,i=0;i<e.length-1;i++)n=e[i],t=e[i+1],n.trail=t.start-n.end;(n=e[e.length-1]).trail=this.duration-n.end}},h.prototype.getTransformCalls=function(e){var n=this.timeKey;return this.segments[e]?this.segments[e].map(function(e){return"applyTransform"+e.key+"("+n+", transformed);"}).join("\n"):""};var _={vec3:function(e,n,t){return"vec3 "+e+" = vec3("+(n.x||0).toPrecision(t)+", "+(n.y||0).toPrecision(t)+", "+(n.z||0).toPrecision(t)+");"},vec4:function(e,n,t){return"vec4 "+e+" = vec4("+(n.x||0).toPrecision(t)+", "+(n.y||0).toPrecision(t)+", "+(n.z||0).toPrecision(t)+", "+(n.w||0).toPrecision(t)+");"},delayDuration:function(e){return"\n    float cDelay"+e.key+" = "+e.start.toPrecision(4)+";\n    float cDuration"+e.key+" = "+e.duration.toPrecision(4)+";\n    "},progress:function(e){return 0===e.duration?"float progress = 1.0;":"\n      float progress = clamp(time - cDelay"+e.key+", 0.0, cDuration"+e.key+") / cDuration"+e.key+";\n      "+(e.transition.ease?"progress = "+e.transition.ease+"(progress"+(e.transition.easeParams?", "+e.transition.easeParams.map(function(e){return e.toPrecision(4)}).join(", "):"")+");":"")+"\n      "},renderCheck:function(e){return"if (time < "+e.start.toPrecision(4)+" || time > "+(e.end+e.trail).toPrecision(4)+") return;"}},x={compiler:function(e){return"\n    "+_.delayDuration(e)+"\n    "+_.vec3("cTranslateFrom"+e.key,e.transition.from,2)+"\n    "+_.vec3("cTranslateTo"+e.key,e.transition.to,2)+"\n    \n    void applyTransform"+e.key+"(float time, inout vec3 v) {\n    \n      "+_.renderCheck(e)+"\n      "+_.progress(e)+"\n    \n      v += mix(cTranslateFrom"+e.key+", cTranslateTo"+e.key+", progress);\n    }\n    "},defaultFrom:new n.Vector3(0,0,0)};h.register("translate",x);var y={compiler:function(e){var n=e.transition.origin;return"\n    "+_.delayDuration(e)+"\n    "+_.vec3("cScaleFrom"+e.key,e.transition.from,2)+"\n    "+_.vec3("cScaleTo"+e.key,e.transition.to,2)+"\n    "+(n?_.vec3("cOrigin"+e.key,n,2):"")+"\n    \n    void applyTransform"+e.key+"(float time, inout vec3 v) {\n    \n      "+_.renderCheck(e)+"\n      "+_.progress(e)+"\n    \n      "+(n?"v -= cOrigin"+e.key+";":"")+"\n      v *= mix(cScaleFrom"+e.key+", cScaleTo"+e.key+", progress);\n      "+(n?"v += cOrigin"+e.key+";":"")+"\n    }\n    "},defaultFrom:new n.Vector3(1,1,1)};h.register("scale",y);var b={compiler:function(e){var t=new n.Vector4(e.transition.from.axis.x,e.transition.from.axis.y,e.transition.from.axis.z,e.transition.from.angle),i=e.transition.to.axis||e.transition.from.axis,r=new n.Vector4(i.x,i.y,i.z,e.transition.to.angle),a=e.transition.origin;return"\n    "+_.delayDuration(e)+"\n    "+_.vec4("cRotationFrom"+e.key,t,8)+"\n    "+_.vec4("cRotationTo"+e.key,r,8)+"\n    "+(a?_.vec3("cOrigin"+e.key,a,2):"")+"\n    \n    void applyTransform"+e.key+"(float time, inout vec3 v) {\n      "+_.renderCheck(e)+"\n      "+_.progress(e)+"\n\n      "+(a?"v -= cOrigin"+e.key+";":"")+"\n      vec3 axis = normalize(mix(cRotationFrom"+e.key+".xyz, cRotationTo"+e.key+".xyz, progress));\n      float angle = mix(cRotationFrom"+e.key+".w, cRotationTo"+e.key+".w, progress);\n      vec4 q = quatFromAxisAngle(axis, angle);\n      v = rotateVector(q, v);\n      "+(a?"v += cOrigin"+e.key+";":"")+"\n    }\n    "},defaultFrom:{axis:new n.Vector3,angle:0}};h.register("rotate",b),e.BasicAnimationMaterial=i,e.LambertAnimationMaterial=r,e.PhongAnimationMaterial=a,e.StandardAnimationMaterial=o,e.PointsAnimationMaterial=s,e.DepthAnimationMaterial=f,e.DistanceAnimationMaterial=l,e.PrefabBufferGeometry=c,e.MultiPrefabBufferGeometry=u,e.ModelBufferGeometry=p,e.PointBufferGeometry=d,e.ShaderChunk=g,e.Timeline=h,e.TimelineSegment=m,e.TimelineChunks=_,e.TranslationSegment=x,e.ScaleSegment=y,e.RotationSegment=b,e.Utils=v,Object.defineProperty(e,"__esModule",{value:!0})});
    </script>
    <script>
        window.addEventListener('load', function () {
            // CodePen code adapted for this project
            function initThreeJSAnimation() {
                var root = new THREERoot({
                    createCameraControls: !true,
                    antialias: (window.devicePixelRatio === 1),
                    fov: 80
                });

                root.renderer.setClearColor(0x000000, 0);
                root.renderer.setPixelRatio(window.devicePixelRatio || 1);
                root.camera.position.set(0, 0, 60);

                var width = 100;
                var height = 60;

                var slide = new Slide(width, height, 'out');

                const textStyle = {
                    font: "700 48px 'butler_medium', serif",
                    color: '#ffffff',
                    backgroundColor: '#252525'
                };
                const textTexture = createTextTexture('LT STUDIO DESIGN', textStyle);
                slide.setImage(textTexture);

                root.scene.add(slide);

                var tl = new TimelineMax({
                    paused: true,
                    onComplete: function () {
                        document.getElementById('three-container').style.opacity = 0;
                        const introScreen = document.getElementById('intro-screen');
                        const mainScreen = document.getElementById('main-screen');

                        introScreen.style.transition = 'opacity 1s ease-out';
                        introScreen.style.opacity = '0';

                        setTimeout(() => {
                            introScreen.classList.add('hidden');
                            introScreen.style.display = 'none';

                            mainScreen.classList.add('visible');
                            mainScreen.style.opacity = '1';

                            // Initialize main screen
                            setTimeout(() => {
                                changeProject(0);
                                startProgress();
                                console.log('‚úÖ Main screen inicializado');
                            }, 300);
                        }, 1000);
                    }
                });

                tl.add(slide.transition(), 0);

                // This will be called when the intro text animation finishes
                window.startFragmentAnimation = function() {
                    document.getElementById('three-container').classList.add('visible');
                    tl.play();
                }
            }

            ////////////////////
            // CLASSES
            ////////////////////

            function Slide(width, height, animationPhase) {
                var plane = new THREE.PlaneGeometry(width, height, width * 2, height * 2);

                THREE.BAS.Utils.separateFaces(plane);

                var geometry = new SlideGeometry(plane);

                geometry.bufferUVs();

                var aAnimation = geometry.createAttribute('aAnimation', 2);
                var aStartPosition = geometry.createAttribute('aStartPosition', 3);
                var aControl0 = geometry.createAttribute('aControl0', 3);
                var aControl1 = geometry.createAttribute('aControl1', 3);
                var aEndPosition = geometry.createAttribute('aEndPosition', 3);

                var i, i2, i3, i4, v;

                var minDuration = 0.8;
                var maxDuration = 1.2;
                var maxDelayX = 0.9;
                var maxDelayY = 0.125;
                var stretch = 0.11;

                this.totalDuration = maxDuration + maxDelayX + maxDelayY + stretch;

                var startPosition = new THREE.Vector3();
                var control0 = new THREE.Vector3();
                var control1 = new THREE.Vector3();
                var endPosition = new THREE.Vector3();

                var tempPoint = new THREE.Vector3();

                function getControlPoint0(centroid) {
                    var signY = Math.sign(centroid.y);

                    tempPoint.x = THREE.Math.randFloat(0.1, 0.3) * 50;
                    tempPoint.y = signY * THREE.Math.randFloat(0.1, 0.3) * 70;
                    tempPoint.z = THREE.Math.randFloatSpread(20);

                    return tempPoint;
                }

                function getControlPoint1(centroid) {
                    var signY = Math.sign(centroid.y);

                    tempPoint.x = THREE.Math.randFloat(0.3, 0.6) * 50;
                    tempPoint.y = -signY * THREE.Math.randFloat(0.3, 0.6) * 70;
                    tempPoint.z = THREE.Math.randFloatSpread(20);

                    return tempPoint;
                }

                for (i = 0, i2 = 0, i3 = 0, i4 = 0; i < geometry.faceCount; i++, i2 += 6, i3 += 9, i4 += 12) {
                    var face = plane.faces[i];
                    var centroid = THREE.BAS.Utils.computeCentroid(plane, face);

                    // animation
                    var duration = THREE.Math.randFloat(minDuration, maxDuration);
                    var delayX = THREE.Math.mapLinear(centroid.x, -width * 0.5, width * 0.5, 0.0, maxDelayX);
                    var delayY;

                    if (animationPhase === 'in') {
                        delayY = THREE.Math.mapLinear(Math.abs(centroid.y), 0, height * 0.5, 0.0, maxDelayY)
                    }
                    else {
                        delayY = THREE.Math.mapLinear(Math.abs(centroid.y), 0, height * 0.5, maxDelayY, 0.0)
                    }

                    for (v = 0; v < 6; v += 2) {
                        aAnimation.array[i2 + v]     = delayX + delayY + (Math.random() * stretch * duration);
                        aAnimation.array[i2 + v + 1] = duration;
                    }

                    // positions

                    endPosition.copy(centroid);
                    startPosition.copy(centroid);

                    if (animationPhase === 'in') {
                        control0.copy(centroid).sub(getControlPoint0(centroid));
                        control1.copy(centroid).sub(getControlPoint1(centroid));
                    }
                    else { // out
                        control0.copy(centroid).add(getControlPoint0(centroid));
                        control1.copy(centroid).add(getControlPoint1(centroid));
                    }

                    for (v = 0; v < 9; v += 3) {
                        aStartPosition.array[i3 + v]     = startPosition.x;
                        aStartPosition.array[i3 + v + 1] = startPosition.y;
                        aStartPosition.array[i3 + v + 2] = startPosition.z;

                        aControl0.array[i3 + v]     = control0.x;
                        aControl0.array[i3 + v + 1] = control0.y;
                        aControl0.array[i3 + v + 2] = control0.z;

                        aControl1.array[i3 + v]     = control1.x;
                        aControl1.array[i3 + v + 1] = control1.y;
                        aControl1.array[i3 + v + 2] = control1.z;

                        aEndPosition.array[i3 + v]     = endPosition.x;
                        aEndPosition.array[i3 + v + 1] = endPosition.y;
                        aEndPosition.array[i3 + v + 2] = endPosition.z;
                    }
                }

                var material = new THREE.BAS.BasicAnimationMaterial(
                    {
                    shading: THREE.FlatShading,
                    side: THREE.DoubleSide,
                    uniforms: {
                        uTime: {type: 'f', value: 0}
                    },
                    shaderFunctions: [
                        THREE.BAS.ShaderChunk['cubic_bezier'],
                        //THREE.BAS.ShaderChunk[(animationPhase === 'in' ? 'ease_out_cubic' : 'ease_in_cubic')],
                        THREE.BAS.ShaderChunk['ease_in_out_cubic'],
                        THREE.BAS.ShaderChunk['quaternion_rotation']
                    ],
                    shaderParameters: [
                        'uniform float uTime;',
                        'attribute vec2 aAnimation;',
                        'attribute vec3 aStartPosition;',
                        'attribute vec3 aControl0;',
                        'attribute vec3 aControl1;',
                        'attribute vec3 aEndPosition;',
                    ],
                    shaderVertexInit: [
                        'float tDelay = aAnimation.x;',
                        'float tDuration = aAnimation.y;',
                        'float tTime = clamp(uTime - tDelay, 0.0, tDuration);',
                        'float tProgress = ease(tTime, 0.0, 1.0, tDuration);'
                        //'float tProgress = tTime / tDuration;'
                    ],
                    shaderTransformPosition: [
                        (animationPhase === 'in' ? 'transformed *= tProgress;' : 'transformed *= 1.0 - tProgress;'),
                        'transformed += cubicBezier(aStartPosition, aControl0, aControl1, aEndPosition, tProgress);'
                    ]
                    },
                    {
                    map: new THREE.Texture(),
                    }
                );

                THREE.Mesh.call(this, geometry, material);

                this.frustumCulled = false;
            }
            Slide.prototype = Object.create(THREE.Mesh.prototype);
            Slide.prototype.constructor = Slide;
            Object.defineProperty(Slide.prototype, 'time', {
                get: function () {
                    return this.material.uniforms['uTime'].value;
                },
                set: function (v) {
                    this.material.uniforms['uTime'].value = v;
                }
            });

            Slide.prototype.setImage = function(image) {
                this.material.uniforms.map.value.image = image;
                this.material.uniforms.map.value.needsUpdate = true;
            };

            Slide.prototype.transition = function() {
                return TweenMax.fromTo(this, 3.0, {time:0.0}, {time:this.totalDuration, ease:Power0.easeInOut});
            };


            function SlideGeometry(model) {
                THREE.BAS.ModelBufferGeometry.call(this, model);
            }
            SlideGeometry.prototype = Object.create(THREE.BAS.ModelBufferGeometry.prototype);
            SlideGeometry.prototype.constructor = SlideGeometry;
            SlideGeometry.prototype.bufferPositions = function () {
                var positionBuffer = this.createAttribute('position', 3).array;

                for (var i = 0; i < this.faceCount; i++) {
                    var face = this.modelGeometry.faces[i];
                    var centroid = THREE.BAS.Utils.computeCentroid(this.modelGeometry, face);

                    var a = this.modelGeometry.vertices[face.a];
                    var b = this.modelGeometry.vertices[face.b];
                    var c = this.modelGeometry.vertices[face.c];

                    positionBuffer[face.a * 3]     = a.x - centroid.x;
                    positionBuffer[face.a * 3 + 1] = a.y - centroid.y;
                    positionBuffer[face.a * 3 + 2] = a.z - centroid.z;

                    positionBuffer[face.b * 3]     = b.x - centroid.x;
                    positionBuffer[face.b * 3 + 1] = b.y - centroid.y;
                    positionBuffer[face.b * 3 + 2] = b.z - centroid.z;

                    positionBuffer[face.c * 3]     = c.x - centroid.x;
                    positionBuffer[face.c * 3 + 1] = c.y - centroid.y;
                    positionBuffer[face.c * 3 + 2] = c.z - centroid.z;
                }
            };


            function THREERoot(params) {
                params = utils.extend({
                    fov: 60,
                    zNear: 10,
                    zFar: 100000,

                    createCameraControls: true
                }, params);

                this.renderer = new THREE.WebGLRenderer({
                    antialias: params.antialias,
                    alpha: true
                });
                this.renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
                document.getElementById('three-container').appendChild(this.renderer.domElement);

                this.camera = new THREE.PerspectiveCamera(
                    params.fov,
                    window.innerWidth / window.innerHeight,
                    params.zNear,
                    params.zfar
                );

                this.scene = new THREE.Scene();

                if (params.createCameraControls) {
                    this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                }

                this.resize = this.resize.bind(this);
                this.tick = this.tick.bind(this);

                this.resize();
                this.tick();

                window.addEventListener('resize', this.resize, false);
            }
            THREERoot.prototype = {
                tick: function () {
                    this.update();
                    this.render();
                    requestAnimationFrame(this.tick);
                },
                update: function () {
                    this.controls && this.controls.update();
                },
                render: function () {
                    this.renderer.render(this.scene, this.camera);
                },
                resize: function () {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();

                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                }
            };

            ////////////////////
            // UTILS
            ////////////////////

            var utils = {
                extend: function (dst, src) {
                    for (var key in src) {
                    dst[key] = src[key];
                    }

                    return dst;
                },
                randSign: function () {
                    return Math.random() > 0.5 ? 1 : -1;
                },
                ease: function (ease, t, b, c, d) {
                    return b + ease.getRatio(t / d) * c;
                },
                fibSpherePoint: (function () {
                    var vec = {x: 0, y: 0, z: 0};
                    var G = Math.PI * (3 - Math.sqrt(5));

                    return function (i, n, radius) {
                    var step = 2.0 / n;
                    var r, phi;

                    vec.y = i * step - 1 + (step * 0.5);
                    r = Math.sqrt(1 - vec.y * vec.y);
                    phi = i * G;
                    vec.x = Math.cos(phi) * r;
                    vec.z = Math.sin(phi) * r;

                    radius = radius || 1;

                    vec.x *= radius;
                    vec.y *= radius;
                    vec.z *= radius;

                    return vec;
                    }
                })(),
                spherePoint: (function () {
                    return function (u, v) {
                    u === undefined && (u = Math.random());
                    v === undefined && (v = Math.random());

                    var theta = 2 * Math.PI * u;
                    var phi = Math.acos(2 * v - 1);

                    var vec = {};
                    vec.x = (Math.sin(phi) * Math.cos(theta));
                    vec.y = (Math.sin(phi) * Math.sin(theta));
                    vec.z = (Math.cos(phi));

                    return vec;
                    }
                })()
            };

            initThreeJSAnimation();
        });
    </script>
</body>
</html>
